<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zelda-Inspired 2.5D Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a2f0a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #8B4513;
            min-width: 120px;
        }
        
        #ui div {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #8B4513;
        }
        
        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #8B4513;
            border-radius: 10px;
            z-index: 100;
            padding: 5px;
            box-sizing: border-box;
        }
        
        .minimap-title {
            color: #FFD700;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 0 5px 0;
            text-shadow: 1px 1px 0px #000;
            margin: 0;
        }
        
        #minimapCanvas {
            display: block;
            margin: 0 auto;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>‚ô•‚ô•‚ô• Health</div>
            <div>üíé Rupees: 0</div>
            <div>üìç Position: (0, 0)</div>
            <div id="essence-display">üîÆ Essence: None</div>
        </div>
        <div class="minimap">
            <div class="minimap-title">Map</div>
            <canvas id="minimapCanvas" width="140" height="140"></canvas>
        </div>
        <div class="controls">
            üéÆ WASD or Arrow Keys to move<br>
            üîÆ E - Get/Transfer Essence<br>
            ü§ù F - Interact with Objects<br>
            üì¶ Push box by walking into it
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, character, world;
        let keys = {};
        let keyPressed = {};
        let isMoving = false;
        let movementSpeed = 0.15; // Animation speed for tile movement
        let minimapCanvas, minimapCtx;
        
        // Box and essence system
        let pushableBox;
        let boxGridPos = { x: 2, z: 2 }; // Starting position
        let playerEssence = null; // What essence the player is carrying
        let boxEssence = null; // What essence the box currently has
        let interactionObjects = []; // Objects that can give essence or be interacted with
        
        // Grid system
        const TILE_SIZE = 2;  // Each tile is 2x2 units
        const GRID_SIZE = 51; // 51x51 grid (odd number for center at (0,0))
        const HALF_GRID = Math.floor(GRID_SIZE / 2);
        
        // Character position in grid coordinates
        let characterGridPos = { x: 0, z: 0 };
        let characterPosition = { x: 0, z: 0 };
        
        // Grid occupancy map (true = occupied, false = empty)
        let gridMap = {};
        
        // Initialize grid map
        function initGridMap() {
            gridMap = {};
            for (let x = -HALF_GRID; x <= HALF_GRID; x++) {
                for (let z = -HALF_GRID; z <= HALF_GRID; z++) {
                    gridMap[`${x},${z}`] = false;
                }
            }
        }
        
        // Convert grid coordinates to world coordinates
        function gridToWorld(gridX, gridZ) {
            return {
                x: gridX * TILE_SIZE,
                z: gridZ * TILE_SIZE
            };
        }
        
        // Convert world coordinates to grid coordinates
        function worldToGrid(worldX, worldZ) {
            return {
                x: Math.round(worldX / TILE_SIZE),
                z: Math.round(worldZ / TILE_SIZE)
            };
        }
        
        // Check if a grid position is valid and not occupied
        function isValidGridPosition(gridX, gridZ) {
            const key = `${gridX},${gridZ}`;
            const withinBounds = gridX >= -HALF_GRID && gridX <= HALF_GRID && 
                                gridZ >= -HALF_GRID && gridZ <= HALF_GRID;
            
            // Also check if it's the box position (for pushing validation)
            const isBoxPosition = (gridX === boxGridPos.x && gridZ === boxGridPos.z);
            
            return withinBounds && !gridMap[key] && !isBoxPosition;
        }
        
        // Set grid position as occupied
        function setGridOccupied(gridX, gridZ, occupied = true) {
            const key = `${gridX},${gridZ}`;
            if (gridMap.hasOwnProperty(key)) {
                gridMap[key] = occupied;
            }
        }
        
        // Initialize the game
        function init() {
            // Initialize grid system
            initGridMap();
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2f0a); // Dark green to match boundaries
            
            // Create orthographic camera for top-down 2.5D view
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 20;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position camera for top-down view with slight angle
            camera.position.set(0, 15, 8);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            setupLighting();
            createWorld();
            createCharacter();
            setupControls();
            initMinimap();
            
            animate();
        }
        
        function setupLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light for shadows (like sunlight)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }
        
        function createWorld() {
            world = new THREE.Group();
            
            // Create grid-based terrain
            createGridTerrain();
            
            // Create objects on specific grid tiles
            createTrees();
            createRocks();
            createWater();
            createPushableBox();
            createTorch(); // First essence object
            
            scene.add(world);
        }
        
        function createGridTerrain() {
            // Create individual tiles for the grid with subtle grid lines
            const tileGeometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c1e });
            const grassMaterial2 = new THREE.MeshLambertMaterial({ color: 0x486b1d }); // Slightly different shade
            
            // Create grid line material (more visible but still subtle)
            const gridLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x3d6919, 
                transparent: true, 
                opacity: 0.4 
            });
            
            for (let gridX = -HALF_GRID; gridX <= HALF_GRID; gridX++) {
                for (let gridZ = -HALF_GRID; gridZ <= HALF_GRID; gridZ++) {
                    const worldPos = gridToWorld(gridX, gridZ);
                    
                    // Create subtle checkerboard pattern for better grid visibility
                    const isEvenTile = (gridX + gridZ) % 2 === 0;
                    const material = isEvenTile ? grassMaterial : grassMaterial2;
                    
                    const tile = new THREE.Mesh(tileGeometry, material);
                    tile.rotation.x = -Math.PI / 2;
                    tile.position.set(worldPos.x, 0, worldPos.z);
                    tile.receiveShadow = true;
                    world.add(tile);
                    
                    // Create a very subtle grid outline
                    const halfTile = TILE_SIZE / 2;
                    const gridGeometry = new THREE.BufferGeometry();
                    const gridVertices = new Float32Array([
                        // Bottom edge
                        -halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        // Right edge
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, halfTile,
                        // Top edge
                        halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        // Left edge
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, -halfTile,
                    ]);
                    
                    gridGeometry.setAttribute('position', new THREE.BufferAttribute(gridVertices, 3));
                    const gridLines = new THREE.LineSegments(gridGeometry, gridLineMaterial);
                    gridLines.position.set(worldPos.x, 0, worldPos.z);
                    world.add(gridLines);
                }
            }
        }
        
        function createTrees() {
            // Define tree positions in grid coordinates
            const treeGridPositions = [
                // Center area trees
                { x: -4, z: -4 }, { x: 4, z: -4 }, { x: -4, z: 4 }, { x: 4, z: 4 },
                { x: -6, z: 0 }, { x: 6, z: 0 }, { x: 0, z: -6 }, { x: 0, z: 6 },
                // Scattered trees across the map
                { x: -10, z: -8 }, { x: 8, z: -12 }, { x: -12, z: 10 }, { x: 12, z: 8 },
                { x: -15, z: -15 }, { x: 15, z: -15 }, { x: -15, z: 15 }, { x: 15, z: 15 },
                { x: -8, z: -20 }, { x: 8, z: 20 }, { x: -20, z: 8 }, { x: 20, z: -8 },
                { x: -18, z: 0 }, { x: 18, z: 0 }, { x: 0, z: -18 }, { x: 0, z: 18 },
                // More scattered placement
                { x: -22, z: -10 }, { x: 22, z: 10 }, { x: -10, z: 22 }, { x: 10, z: -22 },
                // Edge trees (now that we can access the full grid)
                { x: -24, z: -5 }, { x: 24, z: 5 }, { x: -5, z: -24 }, { x: 5, z: 24 },
                { x: -25, z: 0 }, { x: 25, z: 0 }, { x: 0, z: -25 }, { x: 0, z: 25 },
                { x: -23, z: 17 }, { x: 23, z: -17 }, { x: -17, z: 23 }, { x: 17, z: -23 }
            ];
            
            treeGridPositions.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    // Tree trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(worldPos.x, 1, worldPos.z);
                    trunk.castShadow = true;
                    world.add(trunk);
                    
                    // Tree leaves
                    const leavesGeometry = new THREE.SphereGeometry(1.0);
                    const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(worldPos.x, 2.5, worldPos.z);
                    leaves.castShadow = true;
                    world.add(leaves);
                    
                    // Mark this grid position as occupied
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createRocks() {
            // Define rock positions in grid coordinates
            const rockGridPositions = [
                { x: -3, z: -3 }, { x: 3, z: 3 }, { x: -3, z: 3 }, { x: 5, z: -2 },
                { x: -7, z: 2 }, { x: 9, z: -5 }, { x: -11, z: -7 }, { x: 13, z: 6 },
                { x: -16, z: 12 }, { x: 14, z: -16 }, 
                // Additional rocks near the edges
                { x: -21, z: -3 }, { x: 21, z: 3 }, { x: -3, z: -21 }, { x: 3, z: 21 },
                { x: -19, z: 8 }, { x: 19, z: -8 }, { x: -8, z: 19 }, { x: 8, z: -19 },
                { x: -24, z: 12 }, { x: 24, z: -12 }
            ];
            
            rockGridPositions.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    const rockGeometry = new THREE.DodecahedronGeometry(0.6);
                    const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(worldPos.x, 0.3, worldPos.z);
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    world.add(rock);
                    
                    // Mark this grid position as occupied
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createWater() {
            // Create a small pond that occupies multiple tiles
            const pondTiles = [
                { x: -8, z: -8 }, { x: -7, z: -8 }, { x: -6, z: -8 },
                { x: -8, z: -7 }, { x: -7, z: -7 }, { x: -6, z: -7 },
                { x: -8, z: -6 }, { x: -7, z: -6 }, { x: -6, z: -6 }
            ];
            
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.8
            });
            
            pondTiles.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    const waterGeometry = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
                    const water = new THREE.Mesh(waterGeometry, waterMaterial);
                    water.rotation.x = -Math.PI / 2;
                    water.position.set(worldPos.x, 0.02, worldPos.z);
                    world.add(water);
                    
                    // Mark this grid position as occupied (player can't walk on water)
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createPushableBox() {
            const boxWorldPos = gridToWorld(boxGridPos.x, boxGridPos.z);
            
            // Create box geometry
            const boxGeometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            const boxMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.9
            });
            pushableBox = new THREE.Mesh(boxGeometry, boxMaterial);
            pushableBox.position.set(boxWorldPos.x, 0.9, boxWorldPos.z);
            pushableBox.castShadow = true;
            pushableBox.receiveShadow = true;
            
            // Add some box details
            const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            // Add corner details
            for (let i = 0; i < 8; i++) {
                const corner = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08),
                    edgeMaterial
                );
                const x = (i & 1) ? 0.8 : -0.8;
                const y = (i & 2) ? 0.8 : -0.8;
                const z = (i & 4) ? 0.8 : -0.8;
                corner.position.set(x, y, z);
                pushableBox.add(corner);
            }
            
            world.add(pushableBox);
            
            // Mark box position as occupied
            setGridOccupied(boxGridPos.x, boxGridPos.z, true);
        }
        
        function createTorch() {
            // Create a torch object that can give "fire" essence
            const torchPos = { x: -5, z: 3 };
            const torchWorldPos = gridToWorld(torchPos.x, torchPos.z);
            
            if (isValidGridPosition(torchPos.x, torchPos.z)) {
                // Torch base
                const baseGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const torchBase = new THREE.Mesh(baseGeometry, baseMaterial);
                torchBase.position.set(torchWorldPos.x, 0.75, torchWorldPos.z);
                torchBase.castShadow = true;
                world.add(torchBase);
                
                // Flame effect
                const flameGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const flameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4500,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.set(torchWorldPos.x, 1.8, torchWorldPos.z);
                flame.scale.y = 1.3;
                world.add(flame);
                
                // Store torch info for interaction
                interactionObjects.push({
                    gridPos: torchPos,
                    type: 'torch',
                    essence: 'fire',
                    mesh: torchBase,
                    flame: flame,
                    name: 'Torch'
                });
                
                // Mark position as occupied
                setGridOccupied(torchPos.x, torchPos.z, true);
            }
        }
        
        function createCharacter() {
            // Create a simple character representation
            // In a real implementation, you'd load the sprite here
            const characterGeometry = new THREE.BoxGeometry(0.8, 1.6, 0.4);
            const characterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF69B4  // Magenta, matching the sprite
            });
            character = new THREE.Mesh(characterGeometry, characterMaterial);
            
            // Position character at grid center (0, 0)
            characterGridPos = { x: 0, z: 0 };
            const worldPos = gridToWorld(characterGridPos.x, characterGridPos.z);
            character.position.set(worldPos.x, 0.8, worldPos.z);
            characterPosition.x = worldPos.x;
            characterPosition.z = worldPos.z;
            
            character.castShadow = true;
            scene.add(character);
            
            // Add a simple face
            const faceGeometry = new THREE.SphereGeometry(0.15);
            const faceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDDAA });
            const face = new THREE.Mesh(faceGeometry, faceMaterial);
            face.position.set(0, 0.3, 0.25);
            character.add(face);
            
            // Add eyes
            const eyeGeometry = new THREE.SphereGeometry(0.03);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.05, 0.05, 0.1);
            face.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.05, 0.05, 0.1);
            face.add(rightEye);
        }
        
        function setupControls() {
            document.addEventListener('keydown', (event) => {
                if (!keys[event.code] && !keyPressed[event.code]) {
                    keys[event.code] = true;
                    keyPressed[event.code] = true;
                    
                    // Handle movement
                    if (['KeyW', 'KeyS', 'KeyA', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                        handleGridMovement(event.code);
                    }
                    // Handle essence system
                    else if (event.code === 'KeyE') {
                        handleEssenceAction();
                    }
                    // Handle world interaction
                    else if (event.code === 'KeyF') {
                        handleWorldInteraction();
                    }
                }
            });
            
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
                keyPressed[event.code] = false;
            });
        }
        
        function handleGridMovement(keyCode) {
            // Don't allow movement if already moving
            if (isMoving) return;
            
            let newGridX = characterGridPos.x;
            let newGridZ = characterGridPos.z;
            let direction = '';
            
            // Determine new grid position based on key pressed
            switch(keyCode) {
                case 'KeyW':
                case 'ArrowUp':
                    newGridZ -= 1;
                    direction = 'up';
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    newGridZ += 1;
                    direction = 'down';
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    newGridX -= 1;
                    direction = 'left';
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    newGridX += 1;
                    direction = 'right';
                    break;
                default:
                    return; // Invalid key, no movement
            }
            
            // Check if there's a box in the way that needs to be pushed
            if (boxGridPos.x === newGridX && boxGridPos.z === newGridZ) {
                // Calculate where the box would move
                let boxNewX = boxGridPos.x;
                let boxNewZ = boxGridPos.z;
                
                switch(direction) {
                    case 'up': boxNewZ -= 1; break;
                    case 'down': boxNewZ += 1; break;
                    case 'left': boxNewX -= 1; break;
                    case 'right': boxNewX += 1; break;
                }
                
                // Check if box can move to new position
                if (isValidGridPosition(boxNewX, boxNewZ)) {
                    // Move both player and box
                    pushBox(boxNewX, boxNewZ);
                    startMovementAnimation(newGridX, newGridZ, direction);
                }
                // If box can't move, player can't move either
                return;
            }
            
            // Check if the new position is valid (within bounds and not occupied)
            if (isValidGridPosition(newGridX, newGridZ)) {
                // Start movement animation
                startMovementAnimation(newGridX, newGridZ, direction);
            }
        }
        
        let movementData = {
            startPos: { x: 0, z: 0 },
            endPos: { x: 0, z: 0 },
            progress: 0,
            direction: ''
        };
        
        function startMovementAnimation(newGridX, newGridZ, direction) {
            isMoving = true;
            
            // Set up movement data
            movementData.startPos.x = characterPosition.x;
            movementData.startPos.z = characterPosition.z;
            movementData.endPos = gridToWorld(newGridX, newGridZ);
            movementData.progress = 0;
            movementData.direction = direction;
            
            // Rotate character based on direction
            rotateCharacterForDirection(direction);
            
            // Update grid position immediately (for logic)
            characterGridPos.x = newGridX;
            characterGridPos.z = newGridZ;
            
            // Update UI
            updatePositionDisplay();
            updateMinimap();
        }
        
        function rotateCharacterForDirection(direction) {
            switch(direction) {
                case 'up':
                    character.rotation.y = 0;
                    break;
                case 'down':
                    character.rotation.y = Math.PI;
                    break;
                case 'left':
                    character.rotation.y = Math.PI / 2;
                    break;
                case 'right':
                    character.rotation.y = -Math.PI / 2;
                    break;
            }
        }
        
        function updateMovementAnimation() {
            if (!isMoving) return;
            
            movementData.progress += movementSpeed;
            
            if (movementData.progress >= 1) {
                // Movement complete
                movementData.progress = 1;
                isMoving = false;
            }
            
            // Smooth interpolation between start and end positions
            const t = easeInOutCubic(movementData.progress);
            characterPosition.x = lerp(movementData.startPos.x, movementData.endPos.x, t);
            characterPosition.z = lerp(movementData.startPos.z, movementData.endPos.z, t);
            
            // Update character and camera positions
            character.position.x = characterPosition.x;
            character.position.z = characterPosition.z;
            
            // Camera follows smoothly
            camera.position.x = characterPosition.x;
            camera.position.z = characterPosition.z + 8;
            camera.lookAt(characterPosition.x, 0, characterPosition.z);
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function pushBox(newX, newZ) {
            // Clear old position
            setGridOccupied(boxGridPos.x, boxGridPos.z, false);
            
            // Update box position
            boxGridPos.x = newX;
            boxGridPos.z = newZ;
            
            // Set new position as occupied
            setGridOccupied(newX, newZ, true);
            
            // Animate box to new position
            const newWorldPos = gridToWorld(newX, newZ);
            pushableBox.position.x = newWorldPos.x;
            pushableBox.position.z = newWorldPos.z;
            
            updateMinimap();
        }
        
        function handleEssenceAction() {
            if (playerEssence === null) {
                // Try to get essence from nearby object
                getEssenceFromObject();
            } else {
                // Try to transfer essence to box
                transferEssenceToBox();
            }
        }
        
        function handleWorldInteraction() {
            // For future implementation - levers, switches, etc.
            console.log("World interaction - coming soon!");
        }
        
        function getEssenceFromObject() {
            // Get the tile the player is facing
            const facingPos = getFacingPosition();
            
            // Check if there's an interaction object at that position
            const obj = interactionObjects.find(o => 
                o.gridPos.x === facingPos.x && o.gridPos.z === facingPos.z
            );
            
            if (obj && obj.essence) {
                playerEssence = obj.essence;
                updateEssenceDisplay();
                
                // Visual feedback - make object glow or dim
                if (obj.flame) {
                    obj.flame.material.opacity = 0.4; // Dim the flame
                }
                
                console.log(`Collected ${obj.essence} essence from ${obj.name}!`);
            }
        }
        
        function transferEssenceToBox() {
            // Check if player is next to the box
            if (isNextToBox()) {
                boxEssence = playerEssence;
                playerEssence = null;
                updateEssenceDisplay();
                updateBoxAppearance();
                
                console.log(`Transferred ${boxEssence} essence to box!`);
            }
        }
        
        function getFacingPosition() {
            // This is a simplified version - you might want to track actual facing direction
            // For now, we'll check all adjacent positions
            const adjacentPositions = [
                { x: characterGridPos.x, z: characterGridPos.z - 1 }, // North
                { x: characterGridPos.x, z: characterGridPos.z + 1 }, // South
                { x: characterGridPos.x - 1, z: characterGridPos.z }, // West
                { x: characterGridPos.x + 1, z: characterGridPos.z }  // East
            ];
            
            // Return the first valid adjacent position with an object
            for (let pos of adjacentPositions) {
                const obj = interactionObjects.find(o => 
                    o.gridPos.x === pos.x && o.gridPos.z === pos.z
                );
                if (obj) return pos;
            }
            
            return { x: characterGridPos.x, z: characterGridPos.z - 1 }; // Default to north
        }
        
        function isNextToBox() {
            const dx = Math.abs(characterGridPos.x - boxGridPos.x);
            const dz = Math.abs(characterGridPos.z - boxGridPos.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }
        
        function updateEssenceDisplay() {
            const essenceDisplay = document.getElementById('essence-display');
            if (essenceDisplay) {
                if (playerEssence) {
                    const essenceEmoji = getEssenceEmoji(playerEssence);
                    essenceDisplay.textContent = `üîÆ Essence: ${essenceEmoji} ${capitalizeFirst(playerEssence)}`;
                } else {
                    essenceDisplay.textContent = 'üîÆ Essence: None';
                }
            }
        }
        
        function updateBoxAppearance() {
            if (boxEssence === 'fire') {
                // Make box glow orange/red
                pushableBox.material.color.setHex(0xff4500);
                pushableBox.material.emissive.setHex(0x330000);
            } else {
                // Default appearance
                pushableBox.material.color.setHex(0x8B4513);
                pushableBox.material.emissive.setHex(0x000000);
            }
        }
        
        function getEssenceEmoji(essence) {
            const emojis = {
                'fire': 'üî•',
                'wind': 'üí®',
                'cannon': 'üí£',
                'steel': 'üõ°Ô∏è'
            };
            return emojis[essence] || 'üîÆ';
        }
        
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        function updatePositionDisplay() {
            const positionDisplay = document.querySelector('#ui div:nth-child(3)');
            if (positionDisplay) {
                positionDisplay.textContent = `üìç Grid: (${characterGridPos.x}, ${characterGridPos.z})`;
            }
        }
        
        function initMinimap() {
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');
            updateMinimap();
        }
        
        function updateMinimap() {
            const canvas = minimapCanvas;
            const ctx = minimapCtx;
            const size = 140;
            const viewRadius = 8; // Optimized for perfect centering
            
            // Clear canvas and add background
            ctx.clearRect(0, 0, size, size);
            
            // Add a subtle background to show the minimap bounds
            ctx.fillStyle = 'rgba(26, 47, 10, 0.5)';
            ctx.fillRect(0, 0, size, size);
            
            // Calculate tile size on minimap and center it properly
            const gridCount = (viewRadius * 2 + 1);
            const tileSize = Math.floor(size / gridCount);
            const totalGridSize = tileSize * gridCount;
            // Use precise centering - no Math.floor to avoid rounding errors
            const offset = (size - totalGridSize) / 2;
            
            // Get player position
            const playerX = characterGridPos.x;
            const playerZ = characterGridPos.z;
            
            // Draw tiles around player
            for (let x = playerX - viewRadius; x <= playerX + viewRadius; x++) {
                for (let z = playerZ - viewRadius; z <= playerZ + viewRadius; z++) {
                    const screenX = offset + (x - (playerX - viewRadius)) * tileSize;
                    const screenZ = offset + (z - (playerZ - viewRadius)) * tileSize;
                    
                    // Determine tile type
                    const key = `${x},${z}`;
                    const isOccupied = gridMap[key];
                    const isOutOfBounds = x < -HALF_GRID || x > HALF_GRID || z < -HALF_GRID || z > HALF_GRID;
                    
                    // Choose color
                    let color;
                    if (isOutOfBounds) {
                        color = 'rgba(26, 47, 10, 0.8)'; // Same as background but slightly more opaque
                    } else if (isOccupied) {
                        // Different colors for different objects
                        if (isWaterTile(x, z)) {
                            color = '#1E90FF';
                        } else if (isTreeTile(x, z)) {
                            color = '#2d5016';
                        } else {
                            color = '#555555'; // Rock
                        }
                    } else {
                        // Use checkerboard pattern on minimap too
                        const isEvenTile = (x + z) % 2 === 0;
                        color = isEvenTile ? '#4a7c1e' : '#486b1d';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(screenX, screenZ, tileSize, tileSize);
                    
                    // Add subtle grid effect on minimap for valid tiles
                    if (!isOutOfBounds) {
                        ctx.strokeStyle = 'rgba(61, 105, 25, 0.4)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(screenX, screenZ, tileSize, tileSize);
                    }
                }
            }
            
            // Draw box if in view
            if (Math.abs(boxGridPos.x - playerX) <= viewRadius && Math.abs(boxGridPos.z - playerZ) <= viewRadius) {
                const boxScreenX = offset + (boxGridPos.x - (playerX - viewRadius)) * tileSize;
                const boxScreenZ = offset + (boxGridPos.z - (playerZ - viewRadius)) * tileSize;
                
                // Box appearance based on essence
                let boxColor = '#8B4513'; // Default brown
                if (boxEssence === 'fire') {
                    boxColor = '#ff4500'; // Fire orange
                } else if (boxEssence === 'wind') {
                    boxColor = '#87CEEB'; // Sky blue
                } else if (boxEssence === 'cannon') {
                    boxColor = '#2F4F4F'; // Dark slate
                } else if (boxEssence === 'steel') {
                    boxColor = '#C0C0C0'; // Silver
                }
                
                // Box outline
                ctx.fillStyle = '#000000';
                ctx.fillRect(boxScreenX - 1, boxScreenZ - 1, tileSize + 2, tileSize + 2);
                
                // Box
                ctx.fillStyle = boxColor;
                ctx.fillRect(boxScreenX, boxScreenZ, tileSize, tileSize);
            }
            
            // Draw player (perfectly centered)
            const playerScreenX = offset + viewRadius * tileSize;
            const playerScreenZ = offset + viewRadius * tileSize;
            
            // Player outline
            ctx.fillStyle = '#000000';
            ctx.fillRect(playerScreenX - 1, playerScreenZ - 1, tileSize + 2, tileSize + 2);
            
            // Player
            ctx.fillStyle = '#FF69B4';
            ctx.fillRect(playerScreenX, playerScreenZ, tileSize, tileSize);
            
            // Draw essence objects (torch, etc.) if in view
            interactionObjects.forEach(obj => {
                if (Math.abs(obj.gridPos.x - playerX) <= viewRadius && Math.abs(obj.gridPos.z - playerZ) <= viewRadius) {
                    const objScreenX = offset + (obj.gridPos.x - (playerX - viewRadius)) * tileSize;
                    const objScreenZ = offset + (obj.gridPos.z - (playerZ - viewRadius)) * tileSize;
                    
                    let objColor = '#ff4500'; // Default fire color for torch
                    if (obj.type === 'torch') {
                        objColor = playerEssence === obj.essence ? '#cc3300' : '#ff4500'; // Dim if essence taken
                    }
                    
                    ctx.fillStyle = objColor;
                    ctx.fillRect(objScreenX + 1, objScreenZ + 1, tileSize - 2, tileSize - 2);
                }
            });
        }
        
        function isWaterTile(x, z) {
            const pondTiles = [
                { x: -8, z: -8 }, { x: -7, z: -8 }, { x: -6, z: -8 },
                { x: -8, z: -7 }, { x: -7, z: -7 }, { x: -6, z: -7 },
                { x: -8, z: -6 }, { x: -7, z: -6 }, { x: -6, z: -6 }
            ];
            return pondTiles.some(tile => tile.x === x && tile.z === z);
        }
        
        function isTreeTile(x, z) {
            const treeGridPositions = [
                { x: -4, z: -4 }, { x: 4, z: -4 }, { x: -4, z: 4 }, { x: 4, z: 4 },
                { x: -6, z: 0 }, { x: 6, z: 0 }, { x: 0, z: -6 }, { x: 0, z: 6 },
                { x: -10, z: -8 }, { x: 8, z: -12 }, { x: -12, z: 10 }, { x: 12, z: 8 },
                { x: -15, z: -15 }, { x: 15, z: -15 }, { x: -15, z: 15 }, { x: 15, z: 15 },
                { x: -8, z: -20 }, { x: 8, z: 20 }, { x: -20, z: 8 }, { x: 20, z: -8 },
                { x: -18, z: 0 }, { x: 18, z: 0 }, { x: 0, z: -18 }, { x: 0, z: 18 },
                { x: -22, z: -10 }, { x: 22, z: 10 }, { x: -10, z: 22 }, { x: 10, z: -22 },
                { x: -24, z: -5 }, { x: 24, z: 5 }, { x: -5, z: -24 }, { x: 5, z: 24 },
                { x: -25, z: 0 }, { x: 25, z: 0 }, { x: 0, z: -25 }, { x: 0, z: 25 },
                { x: -23, z: 17 }, { x: 23, z: -17 }, { x: -17, z: 23 }, { x: 17, z: -23 }
            ];
            return treeGridPositions.some(tile => tile.x === x && tile.z === z);
        }
        
        function updateCharacterAnimations() {
            // Only apply idle animation when not moving
            if (!isMoving) {
                // Character idle animation - subtle bobbing
                character.position.y = 0.8 + Math.sin(Date.now() * 0.003) * 0.02;
            } else {
                // Walking animation - more pronounced bobbing
                character.position.y = 0.8 + Math.sin(Date.now() * 0.02) * 0.1;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateMovementAnimation();
            updateCharacterAnimations();
            
            // Animate water
            const water = world.children.find(child => 
                child.material && child.material.color && 
                child.material.color.getHex() === 0x1E90FF
            );
            if (water) {
                water.material.opacity = 0.7 + Math.sin(Date.now() * 0.003) * 0.1;
            }
            
            // Animate trees (slight sway)
            world.children.forEach(child => {
                if (child.material && child.material.color && 
                    child.material.color.getHex() === 0x228B22) {
                    child.rotation.z = Math.sin(Date.now() * 0.002 + child.position.x) * 0.05;
                }
            });
            
            // Animate torch flames
            interactionObjects.forEach(obj => {
                if (obj.type === 'torch' && obj.flame) {
                    obj.flame.scale.y = 1.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    obj.flame.rotation.z = Math.sin(Date.now() * 0.008) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 20;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start the game
        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebGL Diagnostic Tool - Drowned Heart</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a1428;
            color: #87CEEB;
            padding: 20px;
            margin: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-result {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #4682B4;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .success { border-color: #00ff00; }
        .warning { border-color: #ffaa00; }
        .error { border-color: #ff0000; }
        
        pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        canvas {
            border: 2px solid #4682B4;
            background: #000;
            display: block;
            margin: 10px 0;
        }
        
        .fps-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid #4682B4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä Drowned Heart - WebGL Diagnostic Tool ‚öì</h1>
        
        <div id="gpu-info" class="test-result">
            <h3>üñ•Ô∏è GPU Information</h3>
            <pre id="gpu-details">Loading...</pre>
        </div>
        
        <div id="webgl-support" class="test-result">
            <h3>üéÆ WebGL Support</h3>
            <pre id="webgl-details">Testing...</pre>
        </div>
        
        <div id="performance-test" class="test-result">
            <h3>‚ö° Performance Test</h3>
            <canvas id="test-canvas" width="800" height="400"></canvas>
            <pre id="performance-details">Running performance test...</pre>
        </div>
        
        <div id="electron-info" class="test-result">
            <h3>üîß Electron Integration</h3>
            <pre id="electron-details">Checking Electron APIs...</pre>
        </div>
        
        <div class="fps-counter" id="fps-counter">FPS: --</div>
    </div>

    <script>
        // GPU and Electron info (if available)
        if (window.electronAPI) {
            document.getElementById('electron-details').textContent = 
                '‚úÖ Electron APIs available\n‚úÖ Context isolation working\n‚úÖ Preload script loaded';
        } else {
            document.getElementById('electron-details').textContent = 
                '‚ùå Not running in Electron\n(This is expected if running in browser)';
        }

        // WebGL diagnostics
        function runWebGLDiagnostics() {
            const canvas = document.getElementById('test-canvas');
            
            // Test WebGL context creation with optimized settings
            const contextAttributes = {
                antialias: false,
                alpha: false,
                depth: true,
                stencil: false,
                preserveDrawingBuffer: false,
                desynchronized: true,
                powerPreference: 'high-performance',
                failIfMajorPerformanceCaveat: false
            };
            
            const gl = canvas.getContext('webgl2', contextAttributes) || 
                      canvas.getContext('webgl', contextAttributes) || 
                      canvas.getContext('experimental-webgl', contextAttributes);
            
            const supportDiv = document.getElementById('webgl-support');
            const detailsElement = document.getElementById('webgl-details');
            
            if (!gl) {
                supportDiv.className = 'test-result error';
                detailsElement.textContent = '‚ùå WebGL not supported!\nTry:\n‚Ä¢ Update browser\n‚Ä¢ Enable hardware acceleration\n‚Ä¢ Update GPU drivers';
                return null;
            }
            
            // Get renderer info
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            let rendererInfo = 'Unknown';
            let vendorInfo = 'Unknown';
            let hardwareStatus = '‚ùì Unknown';
            
            if (debugInfo) {
                rendererInfo = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                vendorInfo = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                
                // Check for software rendering
                if (rendererInfo.includes('SwiftShader') || 
                    rendererInfo.includes('llvmpipe') || 
                    rendererInfo.includes('ANGLE (Software)')) {
                    hardwareStatus = '‚ùå SOFTWARE RENDERING (Poor Performance)';
                    supportDiv.className = 'test-result error';
                } else {
                    hardwareStatus = '‚úÖ Hardware Acceleration Active';
                    supportDiv.className = 'test-result success';
                }
            }
            
            // Get capabilities
            const caps = {
                version: gl.getParameter(gl.VERSION),
                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                maxTextureUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS) || gl.getParameter(gl.MAX_VARYING_COMPONENTS),
                maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
                webgl2: !!canvas.getContext('webgl2')
            };
            
            detailsElement.textContent = `${hardwareStatus}

üñ•Ô∏è Renderer: ${rendererInfo}
üè¢ Vendor: ${vendorInfo}

üìä WebGL Version: ${caps.version}
üìù GLSL Version: ${caps.shadingLanguageVersion}
üé® Max Texture Size: ${caps.maxTextureSize}px
üñºÔ∏è Max Texture Units: ${caps.maxTextureUnits}
üìê Max Varying Vectors: ${caps.maxVaryingVectors}
üéØ Max Vertex Attributes: ${caps.maxVertexAttribs}
üì∫ Max Viewport: ${caps.maxViewportDims[0]}x${caps.maxViewportDims[1]}
‚ö° WebGL 2.0 Support: ${caps.webgl2 ? '‚úÖ Yes' : '‚ùå No'}`;
            
            return gl;
        }
        
        // Simple performance test (from the guide)
        function runPerformanceTest(gl) {
            if (!gl) return;
            
            const canvas = gl.canvas;
            
            // Simple shader program
            const vsSrc = `
                attribute vec2 aPos;
                void main() { 
                    gl_Position = vec4(aPos, 0.0, 1.0); 
                }`;
            
            const fsSrc = `
                precision mediump float;
                uniform float uTime;
                void main() { 
                    float pulse = sin(uTime * 0.002) * 0.5 + 0.5;
                    gl_FragColor = vec4(0.1, 0.7 * pulse, 1.0, 1.0); 
                }`;
            
            function compileShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }
            
            const program = gl.createProgram();
            gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vsSrc));
            gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fsSrc));
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return;
            }
            
            gl.useProgram(program);
            
            // Create triangle
            const vertices = new Float32Array([
                -0.6, -0.6,
                 0.6, -0.6,
                 0.0,  0.6
            ]);
            
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const posLocation = gl.getAttribLocation(program, 'aPos');
            gl.enableVertexAttribArray(posLocation);
            gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);
            
            const timeLocation = gl.getUniformLocation(program, 'uTime');
            
            // Performance monitoring
            let lastTime = performance.now();
            let frameCount = 0;
            let totalTime = 0;
            let fps = 0;
            
            const performanceDiv = document.getElementById('performance-test');
            const performanceDetails = document.getElementById('performance-details');
            const fpsCounter = document.getElementById('fps-counter');
            
            function animate(now) {
                const deltaTime = now - lastTime;
                lastTime = now;
                totalTime += deltaTime;
                frameCount++;
                
                // Calculate FPS every second
                if (totalTime >= 1000) {
                    fps = Math.round(frameCount * 1000 / totalTime);
                    
                    let status, className;
                    if (fps >= 50) {
                        status = '‚úÖ Excellent Performance';
                        className = 'test-result success';
                    } else if (fps >= 30) {
                        status = '‚ö†Ô∏è Acceptable Performance';
                        className = 'test-result warning';
                    } else {
                        status = '‚ùå Poor Performance';
                        className = 'test-result error';
                    }
                    
                    performanceDiv.className = className;
                    performanceDetails.textContent = `${status}
                    
üéØ Current FPS: ${fps}
‚è±Ô∏è Frame Time: ${(1000/fps).toFixed(2)}ms
üìä Target: 60 FPS (16.67ms per frame)

${fps < 30 ? 'üîß Performance Tips:\n‚Ä¢ Close other applications\n‚Ä¢ Update GPU drivers\n‚Ä¢ Check if using integrated graphics' : ''}`;
                    
                    fpsCounter.textContent = `FPS: ${fps}`;
                    fpsCounter.style.color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffaa00' : '#ff0000';
                    
                    frameCount = 0;
                    totalTime = 0;
                }
                
                // Render
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.uniform1f(timeLocation, now);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        }
        
        // Run diagnostics
        const gl = runWebGLDiagnostics();
        runPerformanceTest(gl);
        
        console.log('üîç WebGL Diagnostic Tool loaded. Check console for detailed logs.');
    </script>
</body>
</html>

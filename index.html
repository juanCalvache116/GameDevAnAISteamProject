<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drowned Heart - A Cursed Tale of Love and Betrayal</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #0a1428;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* =================
           MENU STYLES 
           ================= */
        
        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a1428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 1;
            transition: opacity 1.5s ease-out;
        }
        
        .splash-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .splash-logo {
            max-width: 600px;
            width: 90%;
            height: auto;
            margin-bottom: 3rem;
            filter: drop-shadow(0 0 20px rgba(135, 206, 235, 0.6));
            animation: 
                logoGlow 4s ease-in-out infinite alternate,
                logoFloat 6s ease-in-out infinite,
                logoSway 8s ease-in-out infinite alternate;
        }
        
        @keyframes logoGlow {
            from { 
                filter: drop-shadow(0 0 20px rgba(135, 206, 235, 0.6));
            }
            to { 
                filter: drop-shadow(0 0 30px rgba(135, 206, 235, 0.9)) drop-shadow(0 0 60px rgba(70, 130, 180, 0.4));
            }
        }
        
        @keyframes logoFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px);
            }
            25% { 
                transform: translateY(-8px) translateX(2px);
            }
            50% { 
                transform: translateY(-12px) translateX(0px);
            }
            75% { 
                transform: translateY(-5px) translateX(-2px);
            }
        }
        
        @keyframes logoSway {
            0%, 100% { 
                transform: rotate(0deg) scale(1);
            }
            50% { 
                transform: rotate(1deg) scale(1.02);
            }
        }
        
        .splash-prompt {
            font-size: 1.4rem;
            color: #F4A460;
            text-shadow: 2px 2px 0px #1a365d;
            animation: promptPulse 2s ease-in-out infinite;
            font-style: italic;
            font-family: 'Georgia', serif;
        }
        
        @keyframes promptPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* Main Menu - initially hidden */
        .main-menu {
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s ease-out;
            transition-delay: 0.5s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100%;
            position: relative;
            z-index: 10;
        }
        
        .main-menu.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .main-menu.hidden {
            display: none;
        }
        
        /* WebGL Shader Canvas */
        #shaderCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0;
            transition: opacity 2s ease-in;
        }
        
        #shaderCanvas.show {
            opacity: 0.8;
        }
        
        #shaderCanvas.hidden {
            opacity: 0;
        }
        
        /* Main menu logo */
        .main-logo {
            max-width: 400px;
            width: 70%;
            height: auto;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.5));
            animation: 
                mainLogoGlow 4s ease-in-out infinite alternate,
                mainLogoFloat 7s ease-in-out infinite,
                mainLogoBreath 5s ease-in-out infinite alternate;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .main-logo:hover {
            animation-play-state: paused;
            transform: scale(1.05) translateY(-3px);
            filter: drop-shadow(0 0 30px rgba(135, 206, 235, 0.8)) drop-shadow(0 0 60px rgba(70, 130, 180, 0.4));
        }
        
        @keyframes mainLogoGlow {
            from { 
                filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.5));
            }
            to { 
                filter: drop-shadow(0 0 25px rgba(135, 206, 235, 0.8)) drop-shadow(0 0 50px rgba(70, 130, 180, 0.3));
            }
        }
        
        @keyframes mainLogoFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px);
            }
            33% { 
                transform: translateY(-6px) translateX(1px);
            }
            66% { 
                transform: translateY(-3px) translateX(-1px);
            }
        }
        
        @keyframes mainLogoBreath {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
            }
            50% { 
                transform: scale(1.01) rotate(0.5deg);
            }
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #F4A460;
            text-shadow: 2px 2px 0px #1a365d;
            margin-bottom: 1.5rem;
            text-align: center;
            font-style: italic;
            font-family: 'Georgia', serif;
            opacity: 0.9;
        }
        
        /* Menu container - simplified */
        .menu-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
        }
        
        /* Menu buttons */
        .menu-item {
            display: block;
            width: 320px;
            padding: 18px 35px;
            margin: 0;
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            color: #F4A460;
            text-decoration: none;
            text-align: center;
            font-size: 1.4rem;
            font-weight: bold;
            border: 3px solid #4682B4;
            border-radius: 12px;
            text-shadow: 2px 2px 0px #1a365d;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            font-family: 'Georgia', serif;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 100;
        }
        
        .menu-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(135, 206, 235, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .menu-item:hover {
            background: linear-gradient(135deg, #2c5282, #4682B4);
            box-shadow: 0 6px 20px rgba(135, 206, 235, 0.4);
            transform: translateY(-3px);
            border-color: #87CEEB;
            color: #87CEEB;
        }
        
        .menu-item:hover:before {
            left: 100%;
        }
        
        .menu-item:active {
            transform: translateY(0px);
            box-shadow: 0 0 10px rgba(135, 206, 235, 0.4);
        }
        
        /* Special styling for different menu items */
        .menu-item.start-game {
            background: linear-gradient(135deg, #4682B4, #87CEEB);
            animation: pulse 2s infinite;
            color: #ffffff;
            font-weight: bolder;
            text-shadow: 
                2px 2px 0px #1a365d,
                0px 0px 10px rgba(26, 54, 93, 0.8);
            box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4);
            transform: scale(1.05);
        }
        
        @keyframes pulse {
            0% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 0 rgba(135, 206, 235, 0.7);
            }
            70% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 15px rgba(135, 206, 235, 0);
            }
            100% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 0 rgba(135, 206, 235, 0);
            }
        }
        
        .menu-item.start-game:hover {
            background: linear-gradient(135deg, #87CEEB, #B0E0E6);
            color: #ffffff;
            text-shadow: 
                2px 2px 0px #1a365d,
                0px 0px 15px rgba(26, 54, 93, 0.9);
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(135, 206, 235, 0.6);
        }
        
        /* Footer */
        .footer {
            position: absolute;
            bottom: 20px;
            color: #F4A460;
            font-size: 0.9rem;
            text-shadow: 1px 1px 0px #1a365d;
            font-style: italic;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #4682B4;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(135, 206, 235, 0.5);
            scrollbar-width: thin;
            scrollbar-color: #4682B4 rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            color: #87CEEB;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #1a365d;
            font-family: 'Georgia', serif;
        }
        
        .modal-body {
            color: #F4A460;
            font-size: 1.1rem;
            line-height: 1.6;
            text-shadow: 1px 1px 0px #1a365d;
        }
        
        .modal-body h3 {
            color: #87CEEB;
            margin-top: 25px;
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }
        
        .modal-body ul {
            padding-left: 20px;
        }
        
        .modal-body li {
            margin-bottom: 8px;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #87CEEB;
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-btn:hover {
            color: #F4A460;
        }
        
        .key-combo {
            background: rgba(70, 130, 180, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #4682B4;
            font-family: 'Courier New', monospace;
            color: #87CEEB;
        }
        
        /* Webkit scrollbar styling */
        .modal-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .modal-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(70, 130, 180, 0.2);
        }
        
        .modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #4682B4, #2c5282);
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 4px rgba(135, 206, 235, 0.3);
        }
        
        .modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #87CEEB, #4682B4);
            box-shadow: 0 2px 8px rgba(135, 206, 235, 0.5);
        }
        
        .modal-content::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, #87CEEB, #5a9fd4);
        }
        
        .modal-content::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* =================
           GAME STYLES 
           ================= */
        
        .game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            background: #1a2f0a;
            z-index: 5;
        }
        
        .game-container.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .game-canvas {
            display: block;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #8B4513;
            min-width: 120px;
        }
        
        .game-ui div {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #8B4513;
        }
        
        .game-minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #8B4513;
            border-radius: 10px;
            z-index: 100;
            padding: 5px;
            box-sizing: border-box;
        }
        
        .minimap-title {
            color: #FFD700;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 0 5px 0;
            text-shadow: 1px 1px 0px #000;
            margin: 0;
        }
        
        #minimapCanvas {
            display: block;
            margin: 0 auto;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Back to menu button */
        .back-to-menu {
            position: absolute;
            top: 20px;
            right: 190px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            color: #F4A460;
            border: 2px solid #4682B4;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 12px;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .back-to-menu:hover {
            background: linear-gradient(135deg, #2c5282, #4682B4);
            color: #87CEEB;
            transform: translateY(-2px);
        }
        
        /* Responsive adjustments */
        @media (max-height: 700px) {
            .main-logo {
                max-width: 300px;
                width: 60%;
                margin-bottom: 0.5rem;
            }
            .subtitle {
                font-size: 1rem;
                margin-bottom: 1rem;
            }
            .menu-container {
                gap: 15px;
            }
            .menu-item {
                padding: 15px 30px;
                font-size: 1.3rem;
            }
        }
        
        @media (max-width: 480px) {
            .menu-item {
                width: 280px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen" class="splash-screen">
        <img src="assets/img/logo.png" alt="Drowned Heart" class="splash-logo">
        <div class="splash-prompt">Press any key to start...</div>
    </div>
    
    <!-- Underwater Shader Background -->
    <canvas id="shaderCanvas"></canvas>
    
    <!-- Background Music -->
    <audio id="menuMusic" loop>
        <source src="assets/ost/menu.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Main Menu Content -->
    <div id="mainMenu" class="main-menu">
        <img src="assets/img/logo.png" alt="Drowned Heart" class="main-logo" onclick="startGame()" title="Click to start game">
        <div class="subtitle">A Cursed Tale of Love and Betrayal</div>
    
        <div class="menu-container">
            <a href="#" class="menu-item start-game" onclick="startGame()">
                ‚öîÔ∏è START GAME
            </a>
            
            <a href="#" class="menu-item" onclick="showLoadGame()">
                üìú LOAD GAME
            </a>
            
            <a href="#" class="menu-item" onclick="showOptions()">
                ‚öôÔ∏è OPTIONS
            </a>
            
            <a href="#" class="menu-item" onclick="confirmExit()">
                üö™ QUIT GAME
            </a>
        </div>
    </div>
    
    <!-- Game Container -->
    <div id="gameContainer" class="game-container">
        <canvas id="gameCanvas" class="game-canvas"></canvas>
        <button class="back-to-menu" onclick="backToMenu()">üè¥‚Äç‚ò†Ô∏è Back to Menu</button>
        <div class="game-ui">
            <div>‚ô•‚ô•‚ô• Health</div>
            <div>üíé Rupees: 0</div>
            <div>üìç Position: (0, 0)</div>
            <div id="essence-display">üîÆ Essence: None</div>
        </div>
        <div class="game-minimap">
            <div class="minimap-title">Map</div>
            <canvas id="minimapCanvas" width="140" height="140"></canvas>
        </div>
        <div class="game-controls">
            üéÆ WASD or Arrow Keys to move<br>
            üîÆ E - Get/Transfer Essence<br>
            ü§ù F - Interact with Objects<br>
            üì¶ Push box by walking into it
        </div>
    </div>
    
    <!-- Modal for Options -->
    <div id="optionsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('optionsModal')">&times;</span>
            <div class="modal-header">‚öôÔ∏è Ship Options</div>
            <div class="modal-body">
                <h3>üéÆ Graphics Settings</h3>
                <ul>
                    <li><strong>Shader Quality:</strong> High (Underwater Caustics)</li>
                    <li><strong>Resolution:</strong> Adaptive</li>
                    <li><strong>Frame Rate:</strong> 60 FPS Target</li>
                </ul>
                
                <h3>üîä Audio Settings</h3>
                <ul>
                    <li><strong>Background Music:</strong> Enabled</li>
                    <li><strong>Sound Effects:</strong> Enabled</li>
                    <li><strong>Volume:</strong> 50%</li>
                </ul>
                
                <h3>üó∫Ô∏è Controls</h3>
                <ul>
                    <li><span class="key-combo">WASD</span> or <span class="key-combo">Arrow Keys</span> - Navigate the cursed island</li>
                    <li><span class="key-combo">E</span> - Absorb/Transfer amulet essence</li>
                    <li><span class="key-combo">F</span> - Interact with objects</li>
                    <li><span class="key-combo">Mouse</span> - Menu navigation</li>
                </ul>
                
                <h3>‚ö° Gameplay</h3>
                <ul>
                    <li><strong>Difficulty:</strong> Treacherous Waters</li>
                    <li><strong>Auto-save:</strong> Captain's Log Enabled</li>
                    <li><strong>Tutorial:</strong> Available</li>
                </ul>
                
                <p style="margin-top: 25px; font-style: italic; color: #87CEEB;">
                    "Configure your vessel for the cursed voyage ahead..."
                </p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        let gameState = 'splash'; // splash, menu, game
        let gameInitialized = false;
        
        // ==========================================
        // MENU SYSTEM
        // ==========================================
        
        // Audio system
        const menuMusic = document.getElementById('menuMusic');
        let volume = 0.5;
        let splashMode = true;
        
        // WebGL Shader Setup
        let canvas, gl, program, startTime;
        
        function initShader() {
            canvas = document.getElementById('shaderCanvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                console.log('WebGL not supported, falling back to solid background');
                return;
            }
            
            // Vertex shader
            const vertexShaderSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // Fragment shader (converted from Shadertoy)
            const fragmentShaderSource = `
                precision highp float;
                uniform vec2 u_resolution;
                uniform float u_time;
                
                float length2(vec2 p){
                    return dot(p,p);
                }
                
                float noise(vec2 p){
                    return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);
                }
                
                float worley(vec2 p) {
                    float d = 1e30;
                    for (int xo = -1; xo <= 1; ++xo) {
                        for (int yo = -1; yo <= 1; ++yo) {
                            vec2 tp = floor(p) + vec2(float(xo), float(yo));
                            d = min(d, length2(p - tp - noise(tp)));
                        }
                    }
                    return 3.0*exp(-4.0*abs(2.5*d - 1.0));
                }
                
                float fworley(vec2 p) {
                    return sqrt(sqrt(sqrt(
                        worley(p*5.0 + 0.05*u_time) *
                        sqrt(worley(p * 50.0 + 0.12 + -0.1*u_time)) *
                        sqrt(sqrt(worley(p * -10.0 + 0.03*u_time))))));
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                    float t = fworley(uv * u_resolution.xy / 1500.0);
                    t *= exp(-length2(abs(0.7*uv - 1.0)));
                    gl_FragColor = vec4(t * vec3(0.1, 1.1*t, pow(t, 0.5-t)), 1.0);
                }
            `;
            
            // Create and compile shaders
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            // Create program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return;
            }
            
            // Setup geometry (fullscreen quad)
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Start animation
            startTime = Date.now();
            resizeCanvas();
            animateShader();
        }
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function resizeCanvas() {
            if (!canvas || !gl) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        function animateShader() {
            if (!gl || !program) return;
            
            const currentTime = (Date.now() - startTime) / 1000;
            
            gl.useProgram(program);
            
            // Set uniforms
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            gl.uniform1f(timeLocation, currentTime);
            
            // Draw
            gl.clearColor(0.04, 0.08, 0.16, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(animateShader);
        }

        // Initialize when page loads
        window.addEventListener('load', function() {
            // Initialize the underwater shader
            initShader();
            
            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Set music volume but don't start playing yet
            menuMusic.volume = volume;
        });
        
        // Splash screen transition
        function transitionToMainMenu() {
            if (!splashMode) return;
            console.log('Starting transition to main menu');
            
            splashMode = false;
            gameState = 'menu';
            const splashScreen = document.getElementById('splashScreen');
            const mainMenu = document.getElementById('mainMenu');
            const shaderCanvas = document.getElementById('shaderCanvas');
            
            // Start the fade out
            splashScreen.classList.add('fade-out');
            
            // Show shader background immediately
            shaderCanvas.classList.add('show');
            
            // Try to start music immediately (user just interacted)
            menuMusic.volume = volume;
            console.log('Attempting to start music...');
            menuMusic.play().then(() => {
                console.log('Music started successfully');
            }).catch(function(error) {
                console.log('Audio autoplay prevented:', error);
                setTimeout(() => {
                    console.log('Trying music again...');
                    menuMusic.play().catch(e => console.log('Second music attempt failed:', e));
                }, 1000);
            });
            
            // Show main menu after a delay
            setTimeout(() => {
                console.log('Showing main menu');
                mainMenu.classList.add('show');
            }, 800);
            
            // Remove splash screen from DOM after transition
            setTimeout(() => {
                console.log('Removing splash screen');
                splashScreen.remove();
            }, 2000);
        }
        
        // Modal functions
        function showLoadGame() {
            console.log('üîÑ Load Game functionality pending - save system not yet implemented');
        }
        
        function showOptions() {
            document.getElementById('optionsModal').style.display = 'block';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
        
        function confirmExit() {
            if (confirm('üö™ Are you sure you want to quit the game?\n\nYour cursed voyage has only just begun...')) {
                window.close();
            }
        }
        
        // Handle clicks for audio interaction
        document.addEventListener('click', function(event) {
            // Try to start music on any click if it's not playing
            if (gameState === 'menu' && menuMusic.paused) {
                menuMusic.volume = volume;
                menuMusic.play().then(() => {
                    console.log('Music started via click');
                }).catch(error => {
                    console.log('Click music start failed:', error);
                });
            }
        });
        
        // ==========================================
        // GAME TRANSITION FUNCTIONS
        // ==========================================
        
        function startGame() {
            console.log('Starting game...');
            gameState = 'game';
            
            // Hide menu elements
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('shaderCanvas').classList.add('hidden');
            
            // Stop menu music
            menuMusic.pause();
            
            // Show game container
            document.getElementById('gameContainer').classList.add('active');
            
            // Initialize game if not already done
            if (!gameInitialized) {
                initializeGame();
                gameInitialized = true;
            }
        }
        
        function backToMenu() {
            console.log('Back to menu...');
            gameState = 'menu';
            
            // Hide game container
            document.getElementById('gameContainer').classList.remove('active');
            
            // Show menu elements
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('shaderCanvas').classList.remove('hidden');
            
            // Start menu music
            menuMusic.volume = volume;
            menuMusic.play().catch(error => {
                console.log('Failed to restart menu music:', error);
            });
        }
        
        // ==========================================
        // KEYBOARD HANDLING
        // ==========================================
        
        document.addEventListener('keydown', function(event) {
            if (gameState === 'splash') {
                // Any key during splash transitions to main menu
                transitionToMainMenu();
            } else if (gameState === 'menu') {
                if (event.code === 'Escape') {
                    // Handle modal closing or exit confirmation
                    const modals = document.querySelectorAll('.modal');
                    let modalOpen = false;
                    modals.forEach(modal => {
                        if (modal.style.display === 'block') {
                            modal.style.display = 'none';
                            modalOpen = true;
                        }
                    });
                    if (!modalOpen) {
                        confirmExit();
                    }
                } else if (event.code === 'Enter') {
                    startGame();
                }
            } else if (gameState === 'game') {
                if (event.code === 'Escape') {
                    backToMenu();
                } else {
                    // Let game handle other keys
                    handleGameKeyDown(event);
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if (gameState === 'game') {
                handleGameKeyUp(event);
            }
        });
        
        // ==========================================
        // GAME CODE
        // ==========================================
        
        // Game variables
        let scene, camera, renderer, character, world;
        let keys = {};
        let keyPressed = {};
        let isMoving = false;
        let movementSpeed = 0.15;
        let minimapCanvas, minimapCtx;
        
        // Box and essence system
        let pushableBox;
        let boxGridPos = { x: 2, z: 2 };
        let playerEssence = null;
        let boxEssence = null;
        let interactionObjects = [];
        
        // Grid system
        const TILE_SIZE = 2;
        const GRID_SIZE = 51;
        const HALF_GRID = Math.floor(GRID_SIZE / 2);
        
        // Character position in grid coordinates
        let characterGridPos = { x: 0, z: 0 };
        let characterPosition = { x: 0, z: 0 };
        
        // Grid occupancy map
        let gridMap = {};
        
        // Initialize grid map
        function initGridMap() {
            gridMap = {};
            for (let x = -HALF_GRID; x <= HALF_GRID; x++) {
                for (let z = -HALF_GRID; z <= HALF_GRID; z++) {
                    gridMap[`${x},${z}`] = false;
                }
            }
        }
        
        // Convert grid coordinates to world coordinates
        function gridToWorld(gridX, gridZ) {
            return {
                x: gridX * TILE_SIZE,
                z: gridZ * TILE_SIZE
            };
        }
        
        // Convert world coordinates to grid coordinates
        function worldToGrid(worldX, worldZ) {
            return {
                x: Math.round(worldX / TILE_SIZE),
                z: Math.round(worldZ / TILE_SIZE)
            };
        }
        
        // Check if a grid position is valid and not occupied
        function isValidGridPosition(gridX, gridZ) {
            const key = `${gridX},${gridZ}`;
            const withinBounds = gridX >= -HALF_GRID && gridX <= HALF_GRID && 
                                gridZ >= -HALF_GRID && gridZ <= HALF_GRID;
            
            const isBoxPosition = (gridX === boxGridPos.x && gridZ === boxGridPos.z);
            
            return withinBounds && !gridMap[key] && !isBoxPosition;
        }
        
        // Set grid position as occupied
        function setGridOccupied(gridX, gridZ, occupied = true) {
            const key = `${gridX},${gridZ}`;
            if (gridMap.hasOwnProperty(key)) {
                gridMap[key] = occupied;
            }
        }
        
        // Initialize the game
        function initializeGame() {
            console.log('Initializing Three.js game...');
            
            // Initialize grid system
            initGridMap();
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2f0a);
            
            // Create orthographic camera for top-down 2.5D view
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 20;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position camera for top-down view with slight angle
            camera.position.set(0, 15, 8);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            setupLighting();
            createWorld();
            createCharacter();
            initMinimap();
            
            animate();
            console.log('Game initialized successfully!');
        }
        
        function setupLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light for shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }
        
        function createWorld() {
            world = new THREE.Group();
            
            createGridTerrain();
            createTrees();
            createRocks();
            createWater();
            createPushableBox();
            createTorch();
            
            scene.add(world);
        }
        
        function createGridTerrain() {
            // Create individual tiles for the grid with subtle grid lines
            const tileGeometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c1e });
            const grassMaterial2 = new THREE.MeshLambertMaterial({ color: 0x486b1d });
            
            const gridLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x3d6919, 
                transparent: true, 
                opacity: 0.4 
            });
            
            for (let gridX = -HALF_GRID; gridX <= HALF_GRID; gridX++) {
                for (let gridZ = -HALF_GRID; gridZ <= HALF_GRID; gridZ++) {
                    const worldPos = gridToWorld(gridX, gridZ);
                    
                    const isEvenTile = (gridX + gridZ) % 2 === 0;
                    const material = isEvenTile ? grassMaterial : grassMaterial2;
                    
                    const tile = new THREE.Mesh(tileGeometry, material);
                    tile.rotation.x = -Math.PI / 2;
                    tile.position.set(worldPos.x, 0, worldPos.z);
                    tile.receiveShadow = true;
                    world.add(tile);
                    
                    // Create grid outline
                    const halfTile = TILE_SIZE / 2;
                    const gridGeometry = new THREE.BufferGeometry();
                    const gridVertices = new Float32Array([
                        -halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, halfTile,
                        halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, -halfTile,
                    ]);
                    
                    gridGeometry.setAttribute('position', new THREE.BufferAttribute(gridVertices, 3));
                    const gridLines = new THREE.LineSegments(gridGeometry, gridLineMaterial);
                    gridLines.position.set(worldPos.x, 0, worldPos.z);
                    world.add(gridLines);
                }
            }
        }
        
        function createTrees() {
            const treeGridPositions = [
                { x: -4, z: -4 }, { x: 4, z: -4 }, { x: -4, z: 4 }, { x: 4, z: 4 },
                { x: -6, z: 0 }, { x: 6, z: 0 }, { x: 0, z: -6 }, { x: 0, z: 6 },
                { x: -10, z: -8 }, { x: 8, z: -12 }, { x: -12, z: 10 }, { x: 12, z: 8 },
                { x: -15, z: -15 }, { x: 15, z: -15 }, { x: -15, z: 15 }, { x: 15, z: 15 },
                { x: -8, z: -20 }, { x: 8, z: 20 }, { x: -20, z: 8 }, { x: 20, z: -8 },
                { x: -18, z: 0 }, { x: 18, z: 0 }, { x: 0, z: -18 }, { x: 0, z: 18 },
                { x: -22, z: -10 }, { x: 22, z: 10 }, { x: -10, z: 22 }, { x: 10, z: -22 },
                { x: -24, z: -5 }, { x: 24, z: 5 }, { x: -5, z: -24 }, { x: 5, z: 24 },
                { x: -25, z: 0 }, { x: 25, z: 0 }, { x: 0, z: -25 }, { x: 0, z: 25 },
                { x: -23, z: 17 }, { x: 23, z: -17 }, { x: -17, z: 23 }, { x: 17, z: -23 }
            ];
            
            treeGridPositions.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    // Tree trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(worldPos.x, 1, worldPos.z);
                    trunk.castShadow = true;
                    world.add(trunk);
                    
                    // Tree leaves
                    const leavesGeometry = new THREE.SphereGeometry(1.0);
                    const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(worldPos.x, 2.5, worldPos.z);
                    leaves.castShadow = true;
                    world.add(leaves);
                    
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createRocks() {
            const rockGridPositions = [
                { x: -3, z: -3 }, { x: 3, z: 3 }, { x: -3, z: 3 }, { x: 5, z: -2 },
                { x: -7, z: 2 }, { x: 9, z: -5 }, { x: -11, z: -7 }, { x: 13, z: 6 },
                { x: -16, z: 12 }, { x: 14, z: -16 }, 
                { x: -21, z: -3 }, { x: 21, z: 3 }, { x: -3, z: -21 }, { x: 3, z: 21 },
                { x: -19, z: 8 }, { x: 19, z: -8 }, { x: -8, z: 19 }, { x: 8, z: -19 },
                { x: -24, z: 12 }, { x: 24, z: -12 }
            ];
            
            rockGridPositions.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    const rockGeometry = new THREE.DodecahedronGeometry(0.6);
                    const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(worldPos.x, 0.3, worldPos.z);
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    world.add(rock);
                    
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createWater() {
            const pondTiles = [
                { x: -8, z: -8 }, { x: -7, z: -8 }, { x: -6, z: -8 },
                { x: -8, z: -7 }, { x: -7, z: -7 }, { x: -6, z: -7 },
                { x: -8, z: -6 }, { x: -7, z: -6 }, { x: -6, z: -6 }
            ];
            
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.8
            });
            
            pondTiles.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    const waterGeometry = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
                    const water = new THREE.Mesh(waterGeometry, waterMaterial);
                    water.rotation.x = -Math.PI / 2;
                    water.position.set(worldPos.x, 0.02, worldPos.z);
                    world.add(water);
                    
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createPushableBox() {
            const boxWorldPos = gridToWorld(boxGridPos.x, boxGridPos.z);
            
            const boxGeometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            const boxMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.9
            });
            pushableBox = new THREE.Mesh(boxGeometry, boxMaterial);
            pushableBox.position.set(boxWorldPos.x, 0.9, boxWorldPos.z);
            pushableBox.castShadow = true;
            pushableBox.receiveShadow = true;
            
            const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            for (let i = 0; i < 8; i++) {
                const corner = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08),
                    edgeMaterial
                );
                const x = (i & 1) ? 0.8 : -0.8;
                const y = (i & 2) ? 0.8 : -0.8;
                const z = (i & 4) ? 0.8 : -0.8;
                corner.position.set(x, y, z);
                pushableBox.add(corner);
            }
            
            world.add(pushableBox);
            setGridOccupied(boxGridPos.x, boxGridPos.z, true);
        }
        
        function createTorch() {
            const torchPos = { x: -5, z: 3 };
            const torchWorldPos = gridToWorld(torchPos.x, torchPos.z);
            
            if (isValidGridPosition(torchPos.x, torchPos.z)) {
                const baseGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const torchBase = new THREE.Mesh(baseGeometry, baseMaterial);
                torchBase.position.set(torchWorldPos.x, 0.75, torchWorldPos.z);
                torchBase.castShadow = true;
                world.add(torchBase);
                
                const flameGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const flameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4500,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.set(torchWorldPos.x, 1.8, torchWorldPos.z);
                flame.scale.y = 1.3;
                world.add(flame);
                
                interactionObjects.push({
                    gridPos: torchPos,
                    type: 'torch',
                    essence: 'fire',
                    mesh: torchBase,
                    flame: flame,
                    name: 'Torch'
                });
                
                setGridOccupied(torchPos.x, torchPos.z, true);
            }
        }
        
        function createCharacter() {
            const characterGeometry = new THREE.BoxGeometry(0.8, 1.6, 0.4);
            const characterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF69B4
            });
            character = new THREE.Mesh(characterGeometry, characterMaterial);
            
            characterGridPos = { x: 0, z: 0 };
            const worldPos = gridToWorld(characterGridPos.x, characterGridPos.z);
            character.position.set(worldPos.x, 0.8, worldPos.z);
            characterPosition.x = worldPos.x;
            characterPosition.z = worldPos.z;
            
            character.castShadow = true;
            scene.add(character);
            
            const faceGeometry = new THREE.SphereGeometry(0.15);
            const faceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDDAA });
            const face = new THREE.Mesh(faceGeometry, faceMaterial);
            face.position.set(0, 0.3, 0.25);
            character.add(face);
            
            const eyeGeometry = new THREE.SphereGeometry(0.03);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.05, 0.05, 0.1);
            face.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.05, 0.05, 0.1);
            face.add(rightEye);
        }
        
        // Game input handlers
        function handleGameKeyDown(event) {
            if (!keys[event.code] && !keyPressed[event.code]) {
                keys[event.code] = true;
                keyPressed[event.code] = true;
                
                // Handle movement
                if (['KeyW', 'KeyS', 'KeyA', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                    handleGridMovement(event.code);
                }
                // Handle essence system
                else if (event.code === 'KeyE') {
                    handleEssenceAction();
                }
                // Handle world interaction
                else if (event.code === 'KeyF') {
                    handleWorldInteraction();
                }
            }
        }
        
        function handleGameKeyUp(event) {
            keys[event.code] = false;
            keyPressed[event.code] = false;
        }
        
        function handleGridMovement(keyCode) {
            if (isMoving) return;
            
            let newGridX = characterGridPos.x;
            let newGridZ = characterGridPos.z;
            let direction = '';
            
            switch(keyCode) {
                case 'KeyW':
                case 'ArrowUp':
                    newGridZ -= 1;
                    direction = 'up';
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    newGridZ += 1;
                    direction = 'down';
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    newGridX -= 1;
                    direction = 'left';
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    newGridX += 1;
                    direction = 'right';
                    break;
                default:
                    return;
            }
            
            // Check if there's a box in the way that needs to be pushed
            if (boxGridPos.x === newGridX && boxGridPos.z === newGridZ) {
                let boxNewX = boxGridPos.x;
                let boxNewZ = boxGridPos.z;
                
                switch(direction) {
                    case 'up': boxNewZ -= 1; break;
                    case 'down': boxNewZ += 1; break;
                    case 'left': boxNewX -= 1; break;
                    case 'right': boxNewX += 1; break;
                }
                
                if (isValidGridPosition(boxNewX, boxNewZ)) {
                    pushBox(boxNewX, boxNewZ);
                    startMovementAnimation(newGridX, newGridZ, direction);
                }
                return;
            }
            
            if (isValidGridPosition(newGridX, newGridZ)) {
                startMovementAnimation(newGridX, newGridZ, direction);
            }
        }
        
        let movementData = {
            startPos: { x: 0, z: 0 },
            endPos: { x: 0, z: 0 },
            progress: 0,
            direction: ''
        };
        
        function startMovementAnimation(newGridX, newGridZ, direction) {
            isMoving = true;
            
            movementData.startPos.x = characterPosition.x;
            movementData.startPos.z = characterPosition.z;
            movementData.endPos = gridToWorld(newGridX, newGridZ);
            movementData.progress = 0;
            movementData.direction = direction;
            
            rotateCharacterForDirection(direction);
            
            characterGridPos.x = newGridX;
            characterGridPos.z = newGridZ;
            
            updatePositionDisplay();
            updateMinimap();
        }
        
        function rotateCharacterForDirection(direction) {
            switch(direction) {
                case 'up':
                    character.rotation.y = 0;
                    break;
                case 'down':
                    character.rotation.y = Math.PI;
                    break;
                case 'left':
                    character.rotation.y = Math.PI / 2;
                    break;
                case 'right':
                    character.rotation.y = -Math.PI / 2;
                    break;
            }
        }
        
        function updateMovementAnimation() {
            if (!isMoving) return;
            
            movementData.progress += movementSpeed;
            
            if (movementData.progress >= 1) {
                movementData.progress = 1;
                isMoving = false;
            }
            
            const t = easeInOutCubic(movementData.progress);
            characterPosition.x = lerp(movementData.startPos.x, movementData.endPos.x, t);
            characterPosition.z = lerp(movementData.startPos.z, movementData.endPos.z, t);
            
            character.position.x = characterPosition.x;
            character.position.z = characterPosition.z;
            
            camera.position.x = characterPosition.x;
            camera.position.z = characterPosition.z + 8;
            camera.lookAt(characterPosition.x, 0, characterPosition.z);
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function pushBox(newX, newZ) {
            setGridOccupied(boxGridPos.x, boxGridPos.z, false);
            
            boxGridPos.x = newX;
            boxGridPos.z = newZ;
            
            setGridOccupied(newX, newZ, true);
            
            const newWorldPos = gridToWorld(newX, newZ);
            pushableBox.position.x = newWorldPos.x;
            pushableBox.position.z = newWorldPos.z;
            
            updateMinimap();
        }
        
        function handleEssenceAction() {
            if (playerEssence === null) {
                getEssenceFromObject();
            } else {
                transferEssenceToBox();
            }
        }
        
        function handleWorldInteraction() {
            console.log("World interaction - coming soon!");
        }
        
        function getEssenceFromObject() {
            const facingPos = getFacingPosition();
            
            const obj = interactionObjects.find(o => 
                o.gridPos.x === facingPos.x && o.gridPos.z === facingPos.z
            );
            
            if (obj && obj.essence) {
                playerEssence = obj.essence;
                updateEssenceDisplay();
                
                if (obj.flame) {
                    obj.flame.material.opacity = 0.4;
                }
                
                console.log(`Collected ${obj.essence} essence from ${obj.name}!`);
            }
        }
        
        function transferEssenceToBox() {
            if (isNextToBox()) {
                boxEssence = playerEssence;
                playerEssence = null;
                updateEssenceDisplay();
                updateBoxAppearance();
                
                console.log(`Transferred ${boxEssence} essence to box!`);
            }
        }
        
        function getFacingPosition() {
            const adjacentPositions = [
                { x: characterGridPos.x, z: characterGridPos.z - 1 },
                { x: characterGridPos.x, z: characterGridPos.z + 1 },
                { x: characterGridPos.x - 1, z: characterGridPos.z },
                { x: characterGridPos.x + 1, z: characterGridPos.z }
            ];
            
            for (let pos of adjacentPositions) {
                const obj = interactionObjects.find(o => 
                    o.gridPos.x === pos.x && o.gridPos.z === pos.z
                );
                if (obj) return pos;
            }
            
            return { x: characterGridPos.x, z: characterGridPos.z - 1 };
        }
        
        function isNextToBox() {
            const dx = Math.abs(characterGridPos.x - boxGridPos.x);
            const dz = Math.abs(characterGridPos.z - boxGridPos.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }
        
        function updateEssenceDisplay() {
            const essenceDisplay = document.getElementById('essence-display');
            if (essenceDisplay) {
                if (playerEssence) {
                    const essenceEmoji = getEssenceEmoji(playerEssence);
                    essenceDisplay.textContent = `üîÆ Essence: ${essenceEmoji} ${capitalizeFirst(playerEssence)}`;
                } else {
                    essenceDisplay.textContent = 'üîÆ Essence: None';
                }
            }
        }
        
        function updateBoxAppearance() {
            if (boxEssence === 'fire') {
                pushableBox.material.color.setHex(0xff4500);
                pushableBox.material.emissive.setHex(0x330000);
            } else {
                pushableBox.material.color.setHex(0x8B4513);
                pushableBox.material.emissive.setHex(0x000000);
            }
        }
        
        function getEssenceEmoji(essence) {
            const emojis = {
                'fire': 'üî•',
                'wind': 'üí®',
                'cannon': 'üí£',
                'steel': 'üõ°Ô∏è'
            };
            return emojis[essence] || 'üîÆ';
        }
        
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        function updatePositionDisplay() {
            const positionDisplay = document.querySelector('#gameContainer .game-ui div:nth-child(3)');
            if (positionDisplay) {
                positionDisplay.textContent = `üìç Grid: (${characterGridPos.x}, ${characterGridPos.z})`;
            }
        }
        
        function initMinimap() {
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');
            updateMinimap();
        }
        
        function updateMinimap() {
            const canvas = minimapCanvas;
            const ctx = minimapCtx;
            const size = 140;
            const viewRadius = 8;
            
            ctx.clearRect(0, 0, size, size);
            
            ctx.fillStyle = 'rgba(26, 47, 10, 0.5)';
            ctx.fillRect(0, 0, size, size);
            
            const gridCount = (viewRadius * 2 + 1);
            const tileSize = Math.floor(size / gridCount);
            const totalGridSize = tileSize * gridCount;
            const offset = (size - totalGridSize) / 2;
            
            const playerX = characterGridPos.x;
            const playerZ = characterGridPos.z;
            
            for (let x = playerX - viewRadius; x <= playerX + viewRadius; x++) {
                for (let z = playerZ - viewRadius; z <= playerZ + viewRadius; z++) {
                    const screenX = offset + (x - (playerX - viewRadius)) * tileSize;
                    const screenZ = offset + (z - (playerZ - viewRadius)) * tileSize;
                    
                    const key = `${x},${z}`;
                    const isOccupied = gridMap[key];
                    const isOutOfBounds = x < -HALF_GRID || x > HALF_GRID || z < -HALF_GRID || z > HALF_GRID;
                    
                    let color;
                    if (isOutOfBounds) {
                        color = 'rgba(26, 47, 10, 0.8)';
                    } else if (isOccupied) {
                        if (isWaterTile(x, z)) {
                            color = '#1E90FF';
                        } else if (isTreeTile(x, z)) {
                            color = '#2d5016';
                        } else {
                            color = '#555555';
                        }
                    } else {
                        const isEvenTile = (x + z) % 2 === 0;
                        color = isEvenTile ? '#4a7c1e' : '#486b1d';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(screenX, screenZ, tileSize, tileSize);
                    
                    if (!isOutOfBounds) {
                        ctx.strokeStyle = 'rgba(61, 105, 25, 0.4)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(screenX, screenZ, tileSize, tileSize);
                    }
                }
            }
            
            // Draw box if in view
            if (Math.abs(boxGridPos.x - playerX) <= viewRadius && Math.abs(boxGridPos.z - playerZ) <= viewRadius) {
                const boxScreenX = offset + (boxGridPos.x - (playerX - viewRadius)) * tileSize;
                const boxScreenZ = offset + (boxGridPos.z - (playerZ - viewRadius)) * tileSize;
                
                let boxColor = '#8B4513';
                if (boxEssence === 'fire') {
                    boxColor = '#ff4500';
                } else if (boxEssence === 'wind') {
                    boxColor = '#87CEEB';
                } else if (boxEssence === 'cannon') {
                    boxColor = '#2F4F4F';
                } else if (boxEssence === 'steel') {
                    boxColor = '#C0C0C0';
                }
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(boxScreenX - 1, boxScreenZ - 1, tileSize + 2, tileSize + 2);
                
                ctx.fillStyle = boxColor;
                ctx.fillRect(boxScreenX, boxScreenZ, tileSize, tileSize);
            }
            
            // Draw player (perfectly centered)
            const playerScreenX = offset + viewRadius * tileSize;
            const playerScreenZ = offset + viewRadius * tileSize;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(playerScreenX - 1, playerScreenZ - 1, tileSize + 2, tileSize + 2);
            
            ctx.fillStyle = '#FF69B4';
            ctx.fillRect(playerScreenX, playerScreenZ, tileSize, tileSize);
            
            // Draw essence objects
            interactionObjects.forEach(obj => {
                if (Math.abs(obj.gridPos.x - playerX) <= viewRadius && Math.abs(obj.gridPos.z - playerZ) <= viewRadius) {
                    const objScreenX = offset + (obj.gridPos.x - (playerX - viewRadius)) * tileSize;
                    const objScreenZ = offset + (obj.gridPos.z - (playerZ - viewRadius)) * tileSize;
                    
                    let objColor = '#ff4500';
                    if (obj.type === 'torch') {
                        objColor = playerEssence === obj.essence ? '#cc3300' : '#ff4500';
                    }
                    
                    ctx.fillStyle = objColor;
                    ctx.fillRect(objScreenX + 1, objScreenZ + 1, tileSize - 2, tileSize - 2);
                }
            });
        }
        
        function isWaterTile(x, z) {
            const pondTiles = [
                { x: -8, z: -8 }, { x: -7, z: -8 }, { x: -6, z: -8 },
                { x: -8, z: -7 }, { x: -7, z: -7 }, { x: -6, z: -7 },
                { x: -8, z: -6 }, { x: -7, z: -6 }, { x: -6, z: -6 }
            ];
            return pondTiles.some(tile => tile.x === x && tile.z === z);
        }
        
        function isTreeTile(x, z) {
            const treeGridPositions = [
                { x: -4, z: -4 }, { x: 4, z: -4 }, { x: -4, z: 4 }, { x: 4, z: 4 },
                { x: -6, z: 0 }, { x: 6, z: 0 }, { x: 0, z: -6 }, { x: 0, z: 6 },
                { x: -10, z: -8 }, { x: 8, z: -12 }, { x: -12, z: 10 }, { x: 12, z: 8 },
                { x: -15, z: -15 }, { x: 15, z: -15 }, { x: -15, z: 15 }, { x: 15, z: 15 },
                { x: -8, z: -20 }, { x: 8, z: 20 }, { x: -20, z: 8 }, { x: 20, z: -8 },
                { x: -18, z: 0 }, { x: 18, z: 0 }, { x: 0, z: -18 }, { x: 0, z: 18 },
                { x: -22, z: -10 }, { x: 22, z: 10 }, { x: -10, z: 22 }, { x: 10, z: -22 },
                { x: -24, z: -5 }, { x: 24, z: 5 }, { x: -5, z: -24 }, { x: 5, z: 24 },
                { x: -25, z: 0 }, { x: 25, z: 0 }, { x: 0, z: -25 }, { x: 0, z: 25 },
                { x: -23, z: 17 }, { x: 23, z: -17 }, { x: -17, z: 23 }, { x: 17, z: -23 }
            ];
            return treeGridPositions.some(tile => tile.x === x && tile.z === z);
        }
        
        function updateCharacterAnimations() {
            if (!isMoving) {
                character.position.y = 0.8 + Math.sin(Date.now() * 0.003) * 0.02;
            } else {
                character.position.y = 0.8 + Math.sin(Date.now() * 0.02) * 0.1;
            }
        }
        
        function animate() {
            if (gameState !== 'game') return;
            
            requestAnimationFrame(animate);
            
            updateMovementAnimation();
            updateCharacterAnimations();
            
            // Animate water
            const water = world.children.find(child => 
                child.material && child.material.color && 
                child.material.color.getHex() === 0x1E90FF
            );
            if (water) {
                water.material.opacity = 0.7 + Math.sin(Date.now() * 0.003) * 0.1;
            }
            
            // Animate trees
            world.children.forEach(child => {
                if (child.material && child.material.color && 
                    child.material.color.getHex() === 0x228B22) {
                    child.rotation.z = Math.sin(Date.now() * 0.002 + child.position.x) * 0.05;
                }
            });
            
            // Animate torch flames
            interactionObjects.forEach(obj => {
                if (obj.type === 'torch' && obj.flame) {
                    obj.flame.scale.y = 1.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    obj.flame.rotation.z = Math.sin(Date.now() * 0.008) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (gameInitialized) {
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 20;
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
                camera.updateProjectionMatrix();
                
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Ensure smooth loading
        document.body.style.opacity = '1';
    </script>
</body>
</html>

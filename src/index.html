<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; 
                   img-src 'self' data:; 
                   style-src 'self' 'unsafe-inline'; 
                   media-src 'self'; 
                   connect-src 'self'; 
                   frame-ancestors 'none'; 
                   object-src 'none';">
    <title>Drowned Heart - A Cursed Tale of Love and Betrayal</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #0a1428;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* =================
           MENU STYLES 
           ================= */
        
        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a1428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 1;
            transition: opacity 1.5s ease-out;
        }
        
        .splash-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .splash-logo {
            max-width: 600px;
            width: 90%;
            height: auto;
            margin-bottom: 3rem;
            filter: drop-shadow(0 0 20px rgba(135, 206, 235, 0.6));
            animation: 
                logoGlow 4s ease-in-out infinite alternate,
                logoFloat 6s ease-in-out infinite,
                logoSway 8s ease-in-out infinite alternate;
        }
        
        @keyframes logoGlow {
            from { 
                filter: drop-shadow(0 0 20px rgba(135, 206, 235, 0.6));
            }
            to { 
                filter: drop-shadow(0 0 30px rgba(135, 206, 235, 0.9)) drop-shadow(0 0 60px rgba(70, 130, 180, 0.4));
            }
        }
        
        @keyframes logoFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px);
            }
            25% { 
                transform: translateY(-8px) translateX(2px);
            }
            50% { 
                transform: translateY(-12px) translateX(0px);
            }
            75% { 
                transform: translateY(-5px) translateX(-2px);
            }
        }
        
        @keyframes logoSway {
            0%, 100% { 
                transform: rotate(0deg) scale(1);
            }
            50% { 
                transform: rotate(1deg) scale(1.02);
            }
        }
        
        .splash-prompt {
            font-size: 1.4rem;
            color: #F4A460;
            text-shadow: 2px 2px 0px #1a365d;
            animation: promptPulse 2s ease-in-out infinite;
            font-style: italic;
            font-family: 'Georgia', serif;
        }
        
        @keyframes promptPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes subtleShimmer {
            0% { 
                filter: brightness(1.0) hue-rotate(0deg);
            }
            50% { 
                filter: brightness(1.1) hue-rotate(5deg);
            }
            100% { 
                filter: brightness(1.05) hue-rotate(-3deg);
            }
        }
        
        /* Main Menu - initially hidden */
        .main-menu {
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s ease-out;
            transition-delay: 0.5s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100%;
            position: relative;
            z-index: 10;
        }
        
        .main-menu.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .main-menu.hidden {
            display: none;
        }
        
        /* WebGL Shader Canvas */
        #shaderCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0;
            transition: opacity 2s ease-in;
        }
        
        #shaderCanvas.show {
            opacity: 0.8;
        }
        
        #shaderCanvas.hidden {
            opacity: 0;
        }
        
        /* Main menu logo */
        .main-logo {
            max-width: 400px;
            width: 70%;
            height: auto;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.5));
            animation: 
                mainLogoGlow 4s ease-in-out infinite alternate,
                mainLogoFloat 7s ease-in-out infinite,
                mainLogoBreath 5s ease-in-out infinite alternate;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .main-logo:hover {
            animation-play-state: paused;
            transform: scale(1.05) translateY(-3px);
            filter: drop-shadow(0 0 30px rgba(135, 206, 235, 0.8)) drop-shadow(0 0 60px rgba(70, 130, 180, 0.4));
        }
        
        @keyframes mainLogoGlow {
            from { 
                filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.5));
            }
            to { 
                filter: drop-shadow(0 0 25px rgba(135, 206, 235, 0.8)) drop-shadow(0 0 50px rgba(70, 130, 180, 0.3));
            }
        }
        
        @keyframes mainLogoFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px);
            }
            33% { 
                transform: translateY(-6px) translateX(1px);
            }
            66% { 
                transform: translateY(-3px) translateX(-1px);
            }
        }
        
        @keyframes mainLogoBreath {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
            }
            50% { 
                transform: scale(1.01) rotate(0.5deg);
            }
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #F4A460;
            text-shadow: 2px 2px 0px #1a365d;
            margin-bottom: 1.5rem;
            text-align: center;
            font-style: italic;
            font-family: 'Georgia', serif;
            opacity: 0.9;
        }
        
        /* Menu container - simplified */
        .menu-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
        }
        
        /* Menu buttons */
        .menu-item {
            display: block;
            width: 320px;
            padding: 18px 35px;
            margin: 0;
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            color: #F4A460;
            text-decoration: none;
            text-align: center;
            font-size: 1.4rem;
            font-weight: bold;
            border: 3px solid #4682B4;
            border-radius: 12px;
            text-shadow: 2px 2px 0px #1a365d;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            font-family: 'Georgia', serif;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 100;
        }
        
        .menu-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(135, 206, 235, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .menu-item:hover {
            background: linear-gradient(135deg, #2c5282, #4682B4);
            box-shadow: 0 6px 20px rgba(135, 206, 235, 0.4);
            transform: translateY(-3px);
            border-color: #87CEEB;
            color: #87CEEB;
        }
        
        .menu-item:hover:before {
            left: 100%;
        }
        
        .menu-item:active {
            transform: translateY(0px);
            box-shadow: 0 0 10px rgba(135, 206, 235, 0.4);
        }
        
        /* Special styling for different menu items */
        .menu-item.start-game {
            background: linear-gradient(135deg, #4682B4, #87CEEB);
            animation: pulse 2s infinite;
            color: #ffffff;
            font-weight: bolder;
            text-shadow: 
                2px 2px 0px #1a365d,
                0px 0px 10px rgba(26, 54, 93, 0.8);
            box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4);
            transform: scale(1.05);
        }
        
        @keyframes pulse {
            0% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 0 rgba(135, 206, 235, 0.7);
            }
            70% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 15px rgba(135, 206, 235, 0);
            }
            100% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 0 rgba(135, 206, 235, 0);
            }
        }
        
        .menu-item.start-game:hover {
            background: linear-gradient(135deg, #87CEEB, #B0E0E6);
            color: #ffffff;
            text-shadow: 
                2px 2px 0px #1a365d,
                0px 0px 15px rgba(26, 54, 93, 0.9);
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(135, 206, 235, 0.6);
        }
        
        /* Footer */
        .footer {
            position: absolute;
            bottom: 20px;
            color: #F4A460;
            font-size: 0.9rem;
            text-shadow: 1px 1px 0px #1a365d;
            font-style: italic;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #4682B4;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(135, 206, 235, 0.5);
            scrollbar-width: thin;
            scrollbar-color: #4682B4 rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            color: #87CEEB;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #1a365d;
            font-family: 'Georgia', serif;
        }
        
        .modal-body {
            color: #F4A460;
            font-size: 1.1rem;
            line-height: 1.6;
            text-shadow: 1px 1px 0px #1a365d;
        }
        
        .modal-body h3 {
            color: #87CEEB;
            margin-top: 25px;
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }
        
        .modal-body ul {
            padding-left: 20px;
        }
        
        .modal-body li {
            margin-bottom: 8px;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #87CEEB;
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-btn:hover {
            color: #F4A460;
        }
        
        .key-combo {
            background: rgba(70, 130, 180, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #4682B4;
            font-family: 'Courier New', monospace;
            color: #87CEEB;
        }
        
        /* Webkit scrollbar styling */
        .modal-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .modal-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(70, 130, 180, 0.2);
        }
        
        .modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #4682B4, #2c5282);
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 4px rgba(135, 206, 235, 0.3);
        }
        
        .modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #87CEEB, #4682B4);
            box-shadow: 0 2px 8px rgba(135, 206, 235, 0.5);
        }
        
        .modal-content::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, #87CEEB, #5a9fd4);
        }
        
        .modal-content::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* =================
           GAME STYLES 
           ================= */
        
        .game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            background: #1a2f0a;
            z-index: 5;
        }
        
        .game-container.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .game-canvas {
            display: block;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #8B4513;
            min-width: 120px;
        }
        
        .game-ui div {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #8B4513;
        }
        
        .game-minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #8B4513;
            border-radius: 10px;
            z-index: 100;
            padding: 5px;
            box-sizing: border-box;
        }
        
        .minimap-title {
            color: #FFD700;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 0 5px 0;
            text-shadow: 1px 1px 0px #000;
            margin: 0;
        }
        
        #minimapCanvas {
            display: block;
            margin: 0 auto;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Back to menu button */
        .back-to-menu {
            position: absolute;
            top: 20px;
            right: 190px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            color: #F4A460;
            border: 2px solid #4682B4;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 12px;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .back-to-menu:hover {
            background: linear-gradient(135deg, #2c5282, #4682B4);
            color: #87CEEB;
            transform: translateY(-2px);
        }
        
        /* Notification system for menu bar toggle */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #87CEEB;
            padding: 12px 24px;
            border-radius: 8px;
            border: 2px solid #4682B4;
            font-family: 'Georgia', serif;
            font-size: 14px;
            z-index: 9999;
            opacity: 0;
            transform: translateX(-50%) translateY(-10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .notification.fade-out {
            opacity: 0;
            transform: translateX(-50%) translateY(-10px);
        }
        
        /* Responsive adjustments */
        @media (max-height: 700px) {
            .main-logo {
                max-width: 300px;
                width: 60%;
                margin-bottom: 0.5rem;
            }
            .subtitle {
                font-size: 1rem;
                margin-bottom: 1rem;
            }
            .menu-container {
                gap: 15px;
            }
            .menu-item {
                padding: 15px 30px;
                font-size: 1.3rem;
            }
        }
        
        @media (max-width: 480px) {
            .menu-item {
                width: 280px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen" class="splash-screen">
        <img src="assets/img/logo.png" alt="Drowned Heart" class="splash-logo">
        <div class="splash-prompt">Press any key to start...</div>
    </div>
    
    <!-- Underwater Shader Background -->
    <canvas id="shaderCanvas"></canvas>
    
    <!-- Background Music -->
    <audio id="menuMusic" loop>
        <source src="assets/ost/menu.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Main Menu Content -->
    <div id="mainMenu" class="main-menu">
        <img src="assets/img/logo.png" alt="Drowned Heart" class="main-logo" onclick="startGame()" title="Click to start game">
        <div class="subtitle">A Cursed Tale of Love and Betrayal</div>
    
        <div class="menu-container">
            <a href="#" class="menu-item start-game" onclick="startGame()">
                ⚔️ START GAME
            </a>
            
            <a href="#" class="menu-item" onclick="showLoadGame()">
                📜 LOAD GAME
            </a>
            
            <a href="#" class="menu-item" onclick="showOptions()">
                ⚙️ OPTIONS
            </a>
            
            <a href="#" class="menu-item" onclick="confirmExit()">
                🚪 QUIT GAME
            </a>
        </div>
    </div>
    
    <!-- Game Container -->
    <div id="gameContainer" class="game-container">
        <canvas id="gameCanvas" class="game-canvas"></canvas>
        <button class="back-to-menu" onclick="backToMenu()">🏴‍☠️ Back to Menu</button>
        <div class="game-ui">
            <div>♥♥♥ Health</div>
            <div>💎 Rupees: 0</div>
            <div>📍 Position: (0, 0)</div>
            <div id="essence-display">🔮 Essence: None</div>
        </div>
        <div class="game-minimap">
            <div class="minimap-title">Map</div>
            <canvas id="minimapCanvas" width="140" height="140"></canvas>
        </div>
        <div class="game-controls">
            🎮 WASD or Arrow Keys to move<br>
            🔮 E - Get/Transfer Essence<br>
            🤝 F - Interact with Objects<br>
            📦 Push box by walking into it
        </div>
    </div>
    
    <!-- Modal for Options -->
    <div id="optionsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('optionsModal')">&times;</span>
            <div class="modal-header">⚙️ Ship Options</div>
            <div class="modal-body">
                <h3>🎮 Graphics Settings</h3>
                <ul>
                    <li><strong>Shader Quality:</strong> High (Underwater Caustics)</li>
                    <li><strong>Resolution:</strong> Adaptive</li>
                    <li><strong>Frame Rate:</strong> 60 FPS Target</li>
                </ul>
                
                <h3>🔊 Audio Settings</h3>
                <ul>
                    <li><strong>Background Music:</strong> Enabled</li>
                    <li><strong>Sound Effects:</strong> Enabled</li>
                    <li><strong>Volume:</strong> 50%</li>
                </ul>
                
                <h3>🗺️ Controls</h3>
                <ul>
                    <li><span class="key-combo">WASD</span> or <span class="key-combo">Arrow Keys</span> - Navigate the cursed island</li>
                    <li><span class="key-combo">E</span> - Absorb/Transfer amulet essence</li>
                    <li><span class="key-combo">F</span> - Interact with objects</li>
                    <li><span class="key-combo">Mouse</span> - Menu navigation</li>
                </ul>
                
                <h3>⚡ Gameplay</h3>
                <ul>
                    <li><strong>Difficulty:</strong> Treacherous Waters</li>
                    <li><strong>Auto-save:</strong> Captain's Log Enabled</li>
                    <li><strong>Tutorial:</strong> Available</li>
                </ul>
                
                <p style="margin-top: 25px; font-style: italic; color: #87CEEB;">
                    "Configure your vessel for the cursed voyage ahead..."
                </p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        let gameState = 'splash'; // splash, menu, game
        let gameInitialized = false;
        
        // ==========================================
        // MENU SYSTEM
        // ==========================================
        
        // Audio system
        const menuMusic = document.getElementById('menuMusic');
        let volume = 0.5;
        let splashMode = true;
        
        // Performance settings
        const ENABLE_SHADER = true; // Set to false to disable shader for better performance
        const SHADER_QUALITY = 'medium'; // 'low', 'medium', 'high'
        
                 // WebGL Shader Setup
         let canvas, gl, program, startTime;
         
         // Comprehensive WebGL diagnostic function
         function diagnoseWebGLIssues() {
             console.log('🔍 === WebGL Diagnostic Start ===');
             
             // Test basic canvas creation
             const testCanvas = document.createElement('canvas');
             console.log('✅ Canvas element created successfully');
             
             // Test different context types
             const contextTypes = ['webgl2', 'webgl', 'experimental-webgl'];
             const contextAttributes = {
                 antialias: false,
                 alpha: false,
                 depth: true,
                 stencil: false,
                 preserveDrawingBuffer: false,
                 desynchronized: true,
                 powerPreference: 'high-performance',
                 failIfMajorPerformanceCaveat: false
             };
             
             let workingContext = null;
             for (const contextType of contextTypes) {
                 try {
                     const ctx = testCanvas.getContext(contextType, contextAttributes);
                     if (ctx) {
                         console.log(`✅ ${contextType.toUpperCase()} context created successfully`);
                         workingContext = { type: contextType, context: ctx };
                         break;
                     } else {
                         console.log(`❌ ${contextType.toUpperCase()} context creation returned null`);
                     }
                 } catch (error) {
                     console.log(`❌ ${contextType.toUpperCase()} context creation threw error:`, error);
                 }
             }
             
             if (workingContext) {
                 const gl = workingContext.context;
                 
                 // Get detailed GL info
                 console.log(`🎮 Working WebGL context: ${workingContext.type.toUpperCase()}`);
                 console.log('📊 WebGL Version:', gl.getParameter(gl.VERSION));
                 console.log('📝 GLSL Version:', gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
                 
                 // Check for debug extension
                 const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                 if (debugInfo) {
                     const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                     const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                     
                     console.log('🖥️ GPU Renderer:', renderer);
                     console.log('🏢 GPU Vendor:', vendor);
                     
                     // Detect software rendering
                     const isSoftware = renderer.includes('SwiftShader') || 
                                       renderer.includes('llvmpipe') || 
                                       renderer.includes('ANGLE (Software)') ||
                                       renderer.includes('Mesa') ||
                                       renderer.toLowerCase().includes('software');
                     
                     if (isSoftware) {
                         console.error('🚨 SOFTWARE RENDERING DETECTED!');
                         console.error('   This will cause poor performance.');
                         console.error('   Solutions:');
                         console.error('   • Update GPU drivers');
                         console.error('   • Enable hardware acceleration');
                         console.error('   • Check if running in VM/RDP');
                     } else {
                         console.log('✅ Hardware acceleration appears to be working');
                     }
                 } else {
                     console.warn('⚠️ WEBGL_debug_renderer_info extension not available');
                 }
                 
                 // Test basic operations
                 try {
                     gl.clear(gl.COLOR_BUFFER_BIT);
                     console.log('✅ Basic WebGL operations working');
                 } catch (error) {
                     console.error('❌ Basic WebGL operations failed:', error);
                 }
                 
             } else {
                 console.error('🚨 NO WEBGL CONTEXT AVAILABLE!');
                 console.error('   This means WebGL is completely disabled.');
                 console.error('   Check:');
                 console.error('   • Chrome flags: chrome://flags/#disable-webgl');
                 console.error('   • GPU blacklist status');
                 console.error('   • Hardware acceleration enabled');
                 console.error('   • Not running with --disable-gpu flag');
             }
             
             console.log('🔍 === WebGL Diagnostic End ===');
             return workingContext;
         }
         
         function initShader() {
             if (!ENABLE_SHADER) {
                 console.log('🎨 Shader disabled for performance - using solid background');
                 createFallbackBackground();
                 return;
             }
             
             // Run comprehensive diagnostics first
             const diagnosticResult = diagnoseWebGLIssues();
            
                         canvas = document.getElementById('shaderCanvas');
             
             // Optimized WebGL context creation with performance hints
             const contextAttributes = {
                 antialias: false, // Disable for better performance
                 alpha: false, // Opaque canvas for better performance
                 depth: true, // Keep depth buffer for 3D
                 stencil: false, // Disable stencil buffer for performance
                 preserveDrawingBuffer: false, // Better performance
                 desynchronized: true, // Reduce latency
                 powerPreference: 'high-performance', // Request high-performance GPU
                 failIfMajorPerformanceCaveat: false // Don't fail on performance warnings
             };
             
             gl = canvas.getContext('webgl2', contextAttributes) || 
                  canvas.getContext('webgl', contextAttributes) || 
                  canvas.getContext('experimental-webgl', contextAttributes);
            
                         if (!gl) {
                 console.log('❌ WebGL not supported, falling back to CSS background');
                 createFallbackBackground();
                 return;
             }
             
             // WebGL renderer diagnostics
             const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
             if (debugInfo) {
                 const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                 const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                 
                 console.log('🖥️  WebGL Renderer:', renderer);
                 console.log('🏢 WebGL Vendor:', vendor);
                 
                 // Check for software rendering
                 if (renderer.includes('SwiftShader') || renderer.includes('llvmpipe') || 
                     renderer.includes('ANGLE (Software)')) {
                     console.warn('⚠️  SOFTWARE RENDERING DETECTED! Performance will be poor.');
                     console.warn('   → Try updating GPU drivers or enabling hardware acceleration');
                 } else {
                     console.log('✅ Hardware acceleration active');
                 }
             }
             
             // WebGL capabilities diagnostics
             const capabilities = {
                 maxTextures: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                 maxTextureUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                 maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS),
                 maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                 maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS)
             };
             console.log('🎮 WebGL Capabilities:');
             console.table(capabilities);
             
             console.log('✅ WebGL shader initialized successfully');
            
            // Vertex shader
            const vertexShaderSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // Lightweight underwater effect shader (replaces heavy Worley noise)
            const fragmentShaderSource = `
                precision mediump float;
                uniform vec2 u_resolution;
                uniform float u_time;
                
                // Simple noise function
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }
                
                // Smooth noise
                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    
                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }
                
                // Fractal noise for water effect
                float fbm(vec2 p) {
                    float value = 0.0;
                    float freq = 1.0;
                    float amp = 0.5;
                    
                    for(int i = 0; i < 3; i++) {
                        value += amp * noise(p * freq);
                        freq *= 2.0;
                        amp *= 0.5;
                    }
                    return value;
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                    
                    // Create moving water effect
                    vec2 p = uv * 3.0 + u_time * 0.1;
                    float n1 = fbm(p + vec2(u_time * 0.05, 0.0));
                    float n2 = fbm(p + vec2(0.0, u_time * 0.08));
                    
                    // Combine noise for caustics effect
                    float caustics = n1 + n2 * 0.5;
                    caustics = smoothstep(0.3, 1.0, caustics);
                    
                    // Create underwater color gradient
                    vec3 deepBlue = vec3(0.05, 0.15, 0.3);
                    vec3 lightBlue = vec3(0.1, 0.4, 0.6);
                    
                    // Distance from center for vignette
                    float dist = length(uv - 0.5);
                    float vignette = 1.0 - smoothstep(0.3, 0.8, dist);
                    
                    // Final color
                    vec3 color = mix(deepBlue, lightBlue, caustics * vignette);
                    color += caustics * 0.3 * vignette;
                    
                    gl_FragColor = vec4(color, 0.8);
                }
            `;
            
            // Create and compile shaders
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            // Create program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return;
            }
            
            // Setup geometry (fullscreen quad)
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Start animation
            startTime = Date.now();
            resizeCanvas();
            animateShader();
        }
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function resizeCanvas() {
            if (!canvas || !gl) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        function animateShader() {
            if (!gl || !program) return;
            
            const currentTime = (Date.now() - startTime) / 1000;
            
            gl.useProgram(program);
            
            // Set uniforms
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            gl.uniform1f(timeLocation, currentTime);
            
            // Draw
            gl.clearColor(0.04, 0.08, 0.16, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(animateShader);
        }
        
        // Fallback background for when WebGL is disabled or unavailable
        function createFallbackBackground() {
            const canvas = document.getElementById('shaderCanvas');
            if (canvas) {
                // Replace canvas with CSS gradient background
                canvas.style.background = `
                    radial-gradient(ellipse at center, 
                        rgba(16, 64, 112, 0.8) 0%, 
                        rgba(8, 32, 64, 0.9) 50%, 
                        rgba(4, 16, 32, 0.95) 100%),
                    linear-gradient(45deg, 
                        rgba(10, 20, 40, 0.8) 0%, 
                        rgba(5, 30, 60, 0.8) 100%)
                `;
                canvas.style.backgroundSize = '100% 100%, 100% 100%';
                
                // Add subtle CSS animation
                canvas.style.animation = 'subtleShimmer 8s ease-in-out infinite alternate';
            }
        }

        // Initialize when page loads
        window.addEventListener('load', function() {
            // Don't initialize shader immediately to reduce initial lag
            // Shader will be initialized when transitioning to menu
            
            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Set music volume but don't start playing yet
            menuMusic.volume = volume;
        });
        
        // Performance monitoring for smooth transitions
        function logPerformance(label) {
            if (performance && performance.now) {
                console.log(`⚡ ${label}: ${performance.now().toFixed(2)}ms`);
            }
        }
        
        // Optimized splash screen transition
        function transitionToMainMenu() {
            if (!splashMode) return;
            logPerformance('Transition started');
            
            splashMode = false;
            gameState = 'menu';
            const splashScreen = document.getElementById('splashScreen');
            const mainMenu = document.getElementById('mainMenu');
            const shaderCanvas = document.getElementById('shaderCanvas');
            
            // Start the fade out immediately for smooth transition
            requestAnimationFrame(() => {
                splashScreen.classList.add('fade-out');
            });
            
            // Start music asynchronously to avoid blocking
            setTimeout(() => {
                menuMusic.volume = volume;
                menuMusic.play().catch(() => {
                    // Retry once after a short delay if needed
                    setTimeout(() => menuMusic.play().catch(() => {}), 500);
                });
            }, 100);
            
            // Initialize and activate background with optimal timing
            setTimeout(() => {
                logPerformance('Background initialization started');
                // Initialize shader or fallback if not already done
                if (!gl && ENABLE_SHADER) {
                    initShader();
                } else if (!ENABLE_SHADER) {
                    createFallbackBackground();
                }
                requestAnimationFrame(() => {
                    shaderCanvas.classList.add('show');
                    logPerformance('Background visible');
                });
            }, 300);
            
            // Show main menu with smooth timing
            setTimeout(() => {
                requestAnimationFrame(() => {
                    mainMenu.classList.add('show');
                    logPerformance('Menu visible');
                });
            }, 600);
            
            // Clean up splash screen after transition completes
            setTimeout(() => {
                if (splashScreen && splashScreen.parentNode) {
                    splashScreen.remove();
                }
            }, 1800);
        }
        
        // Modal functions
        function showLoadGame() {
            console.log('🔄 Load Game functionality pending - save system not yet implemented');
        }
        
        function showOptions() {
            document.getElementById('optionsModal').style.display = 'block';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
        
        function confirmExit() {
            if (confirm('🚪 Are you sure you want to quit the game?\n\nYour cursed voyage has only just begun...')) {
                window.close();
            }
        }
        
        // Handle clicks for audio interaction
        document.addEventListener('click', function(event) {
            // Try to start music on any click if it's not playing
            if (gameState === 'menu' && menuMusic.paused) {
                menuMusic.volume = volume;
                menuMusic.play().then(() => {
                    console.log('Music started via click');
                }).catch(error => {
                    console.log('Click music start failed:', error);
                });
            }
        });
        
        // ==========================================
        // GAME TRANSITION FUNCTIONS
        // ==========================================
        
        // Reset game state for clean restart
        function resetGameState() {
            console.log('🔄 Resetting game state...');
            
            // Clear Three.js scene objects if they exist
            if (character) {
                scene.remove(character);
                character.geometry.dispose();
                character.material.dispose();
                character = null;
            }
            if (world) {
                // Dispose all children of the world group
                while(world.children.length > 0){
                    const object = world.children[0];
                    scene.remove(object);
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) object.material.dispose();
                    world.remove(object);
                }
                scene.remove(world);
                world = null;
            }

            // Reset input state
            keys = {};
            keyPressed = {};
            isMoving = false;

            // Reset character position and movement (will be re-initialized by createCharacter)
            characterGridPos = { x: 0, z: 0 };
            characterPosition = { x: 0, z: 0 };

            // Reset essence system
            playerEssence = null;
            boxEssence = null;

            // Reset box position to initial from level data (will be re-initialized by createPushableBox)
            if (levelData.box) {
                boxGridPos = { x: levelData.box.x, z: levelData.box.z };
            }

            // Clear interaction objects (will be re-populated by createTorch etc.)
            interactionObjects = [];

            // Reset performance monitoring
            perfLast = performance.now();
            perfAcc = 0;
            perfFrames = 0;

            // Remove FPS display if it exists
            const existingFpsDisplay = document.querySelector('.fps-counter');
            if (existingFpsDisplay) {
                existingFpsDisplay.remove();
                fpsDisplay = null;
            }

            console.log('✅ Game state reset complete');
        }

        async function startGame() {
            console.log('Starting game...');
            gameState = 'game';

            // Hide menu elements
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('shaderCanvas').classList.add('hidden');

            // Stop menu music
            menuMusic.pause();

            // Show game container
            document.getElementById('gameContainer').classList.add('active');

            if (gameInitialized) {
                resetGameState();
            }

            // Initialize game (or re-initialize if resetting) - now correctly awaited
            await initializeGame();
            gameInitialized = true;

            // After initialization, update UI elements and start animation loop
            updatePositionDisplay();
            updateEssenceDisplay();
            updateMinimap();
            animate();
        }
        
        function backToMenu() {
            console.log('Back to menu...');
            gameState = 'menu';
            
            // Clean up any lingering input states
            keys = {};
            keyPressed = {};
            isMoving = false;
            
            // Remove FPS display when leaving game
            const existingFpsDisplay = document.querySelector('.fps-counter');
            if (existingFpsDisplay) {
                existingFpsDisplay.remove();
                fpsDisplay = null;
            }
            
            // Hide game container
            document.getElementById('gameContainer').classList.remove('active');
            
            // Show menu elements
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('shaderCanvas').classList.remove('hidden');
            
            // Start menu music
            menuMusic.volume = volume;
            menuMusic.play().catch(error => {
                console.log('Failed to restart menu music:', error);
            });
            
            console.log('✅ Returned to main menu');
        }
        
        // ==========================================
        // KEYBOARD HANDLING
        // ==========================================
        
        document.addEventListener('keydown', function(event) {
            // Handle F1 key for menu bar toggle (globally)
            if (event.code === 'F1') {
                event.preventDefault(); // Prevent browser's default F1 behavior
                return; // Let Electron main process handle the actual toggle
            }
            
            if (gameState === 'splash') {
                // Any key during splash transitions to main menu
                transitionToMainMenu();
            } else if (gameState === 'menu') {
                if (event.code === 'Escape') {
                    // Handle modal closing or exit confirmation
                    const modals = document.querySelectorAll('.modal');
                    let modalOpen = false;
                    modals.forEach(modal => {
                        if (modal.style.display === 'block') {
                            modal.style.display = 'none';
                            modalOpen = true;
                        }
                    });
                    if (!modalOpen) {
                        confirmExit();
                    }
                } else if (event.code === 'Enter') {
                    startGame();
                }
            } else if (gameState === 'game') {
                if (event.code === 'Escape') {
                    backToMenu();
                } else {
                    // Let game handle other keys
                    handleGameKeyDown(event);
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if (gameState === 'game') {
                handleGameKeyUp(event);
            }
        });
        
        // ==========================================
        // GAME CODE
        // ==========================================
        
        // Game variables
        let scene, camera, renderer, character, world;
        let keys = {};
        let keyPressed = {};
        let isMoving = false;
        let movementSpeed = 0.15;
        let minimapCanvas, minimapCtx;
        
        // Box and essence system
        let pushableBox;
        let boxGridPos; // Declare boxGridPos here
        let playerEssence = null;
        let boxEssence = null;
        let interactionObjects = [];
        
        // Grid system
        const TILE_SIZE = 2;
        const GRID_SIZE = 51;
        const HALF_GRID = Math.floor(GRID_SIZE / 2);
        
        // Character position in grid coordinates
        let characterGridPos = { x: 0, z: 0 };
        let characterPosition = { x: 0, z: 0 };
        
        // Grid occupancy map
        let gridMap = {};
        let levelData = {}; // To store loaded level configuration
        
        // Initialize grid map
        function initGridMap() {
            gridMap = {};
            for (let x = -HALF_GRID; x <= HALF_GRID; x++) {
                for (let z = -HALF_GRID; z <= HALF_GRID; z++) {
                    gridMap[`${x},${z}`] = false;
                }
            }
        }
        
        // Convert grid coordinates to world coordinates
        function gridToWorld(gridX, gridZ) {
            return {
                x: gridX * TILE_SIZE,
                z: gridZ * TILE_SIZE
            };
        }
        
        // Convert world coordinates to grid coordinates
        function worldToGrid(worldX, worldZ) {
            return {
                x: Math.round(worldX / TILE_SIZE),
                z: Math.round(worldZ / TILE_SIZE)
            };
        }
        
        // Check if a grid position is valid and not occupied
        function isValidGridPosition(gridX, gridZ) {
            const key = `${gridX},${gridZ}`;
            const withinBounds = gridX >= -HALF_GRID && gridX <= HALF_GRID && 
                                gridZ >= -HALF_GRID && gridZ <= HALF_GRID;
            
            // Check against dynamic box position and any other occupied spots
            const isBoxPosition = (boxGridPos && gridX === boxGridPos.x && gridZ === boxGridPos.z);
            
            return withinBounds && !gridMap[key] && !isBoxPosition;
        }
        
        // Set grid position as occupied
        function setGridOccupied(gridX, gridZ, occupied = true) {
            const key = `${gridX},${gridZ}`;
            if (gridMap.hasOwnProperty(key)) {
                gridMap[key] = occupied;
            }
        }
        
                     // Initialize the game
             async function initializeGame() {
                 console.log('Initializing Three.js game...');
                 
                 // Load level data before creating the world
                 levelData = await loadLevelData('level_0.cfg');
                 if (Object.keys(levelData).length === 0) {
                     console.error('Game initialization failed: Could not load level data.');
                     // Potentially show an error message to the user or load a default empty level
                     return;
                 }
                 
                 // WebGL capability checks before proceeding
                 const testCanvas = document.createElement('canvas');
                 const testGL = testCanvas.getContext('webgl2') || testCanvas.getContext('webgl');
                 
                 if (testGL) {
                     // Log WebGL capabilities for debugging
                     const caps = {
                         maxTexSize: testGL.getParameter(testGL.MAX_TEXTURE_SIZE),
                         maxTexUnits: testGL.getParameter(testGL.MAX_TEXTURE_IMAGE_UNITS),
                         maxVaryings: testGL.getParameter(testGL.MAX_VARYING_VECTORS) || testGL.getParameter(testGL.MAX_VARYING_COMPONENTS),
                         maxVertAttribs: testGL.getParameter(testGL.MAX_VERTEX_ATTRIBS),
                         webgl2: !!testCanvas.getContext('webgl2')
                     };
                     
                     console.log('🎮 Three.js WebGL Capabilities:');
                     console.table(caps);
                     
                     if (caps.maxTexSize < 1024) {
                         console.warn('⚠️  Very low texture size limit detected:', caps.maxTexSize);
                     }
                     
                     if (caps.webgl2) {
                         console.log('✅ WebGL 2.0 support detected');
                     } else {
                         console.log('ℹ️  Using WebGL 1.0 (WebGL 2.0 not available)');
                     }
                 }
                 
                 // Initialize grid system
                 initGridMap();
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2f0a);
            
            // Create orthographic camera for top-down 2.5D view
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 20;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position camera for top-down view with slight angle
            camera.position.set(0, 15, 8);
            camera.lookAt(0, 0, 0);
            
            // Create optimized renderer with performance hints
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false, // Disable for better performance - use post-processing if needed
                alpha: false, // Opaque canvas for better performance
                depth: true, // Keep depth buffer for 3D rendering
                stencil: false, // Disable stencil buffer for performance
                preserveDrawingBuffer: false, // Better performance 
                powerPreference: 'high-performance', // Request high-performance GPU
                failIfMajorPerformanceCaveat: false // Don't fail on performance warnings
            });
            
            // Set pixel ratio based on device, but cap it for performance
            const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Configure shadows with performance in mind
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Good balance of quality/performance
            
            // Additional performance optimizations
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.LinearToneMapping;
            
            setupLighting();
            createWorld();
            createCharacter();
            initMinimap();
            
            animate();
            console.log('Game initialized successfully!');
        }
        
        function setupLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light for shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }
        
        function createWorld() {
            world = new THREE.Group();
            
            createGridTerrain();
            createTrees();
            createRocks();
            createWater();
            createPushableBox();
            createTorch();
            
            scene.add(world);
        }
        
        function createGridTerrain() {
            // Create individual tiles for the grid with subtle grid lines
            const tileGeometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c1e });
            const grassMaterial2 = new THREE.MeshLambertMaterial({ color: 0x486b1d });
            
            const gridLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x3d6919, 
                transparent: true, 
                opacity: 0.4 
            });
            
            for (let gridX = -HALF_GRID; gridX <= HALF_GRID; gridX++) {
                for (let gridZ = -HALF_GRID; gridZ <= HALF_GRID; gridZ++) {
                    const worldPos = gridToWorld(gridX, gridZ);
                    
                    const isEvenTile = (gridX + gridZ) % 2 === 0;
                    const material = isEvenTile ? grassMaterial : grassMaterial2;
                    
                    const tile = new THREE.Mesh(tileGeometry, material);
                    tile.rotation.x = -Math.PI / 2;
                    tile.position.set(worldPos.x, 0, worldPos.z);
                    tile.receiveShadow = true;
                    world.add(tile);
                    
                    // Create grid outline
                    const halfTile = TILE_SIZE / 2;
                    const gridGeometry = new THREE.BufferGeometry();
                    const gridVertices = new Float32Array([
                        -halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, halfTile,
                        halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, -halfTile,
                    ]);
                    
                    gridGeometry.setAttribute('position', new THREE.BufferAttribute(gridVertices, 3));
                    const gridLines = new THREE.LineSegments(gridGeometry, gridLineMaterial);
                    gridLines.position.set(worldPos.x, 0, worldPos.z);
                    world.add(gridLines);
                }
            }
        }
        
                 function createTrees() {
             // Iterate over loaded tree positions
             if (levelData.terrain && levelData.terrain.trees) {
                 levelData.terrain.trees.forEach(tree => {
                     const [x, z] = tree.pos;
                     if (isValidGridPosition(x, z)) {
                         const worldPos = gridToWorld(x, z);
                         
                         // Get tree properties
                         const variant = tree.variant || 'oak';
                         const size = tree.size || 'medium';
                         
                         // Tree trunk - vary size based on tree size
                         const sizeMultipliers = {
                             small: 0.7, medium: 1.0, large: 1.3, tall: 1.0, huge: 1.6, ancient: 2.0
                         };
                         const heightMultipliers = {
                             small: 0.8, medium: 1.0, large: 1.2, tall: 1.5, huge: 1.4, ancient: 1.8
                         };
                         
                         const sizeMultiplier = sizeMultipliers[size] || 1.0;
                         const heightMultiplier = heightMultipliers[size] || 1.0;
                         
                         const trunkGeometry = new THREE.CylinderGeometry(
                             0.3 * sizeMultiplier, 
                             0.4 * sizeMultiplier, 
                             2 * heightMultiplier
                         );
                         
                         // Tree colors based on variant
                         const trunkColors = {
                             oak: 0x8B4513, palm: 0xD2691E, pine: 0x654321, 
                             dead_tree: 0x696969, ancient_tree: 0x2F4F4F
                         };
                         const leafColors = {
                             oak: 0x228B22, palm: 0x32CD32, pine: 0x006400,
                             dead_tree: 0x8B4513, ancient_tree: 0x556B2F
                         };
                         
                         const trunkMaterial = new THREE.MeshLambertMaterial({ 
                             color: trunkColors[variant] || 0x8B4513 
                         });
                         const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                         trunk.position.set(worldPos.x, 1 * heightMultiplier, worldPos.z);
                         trunk.castShadow = true;
                         world.add(trunk);
                         
                         // Tree leaves (don't add for dead trees)
                         if (variant !== 'dead_tree') {
                             const leavesGeometry = new THREE.SphereGeometry(1.0 * sizeMultiplier);
                             const leavesMaterial = new THREE.MeshLambertMaterial({ 
                                 color: leafColors[variant] || 0x228B22 
                             });
                             const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                             leaves.position.set(worldPos.x, 2.5 * heightMultiplier, worldPos.z);
                             leaves.castShadow = true;
                             world.add(leaves);
                         }
                         
                         setGridOccupied(x, z, true);
                     }
                 });
             }
         }
        
                 function createRocks() {
             // Iterate over loaded rock positions
             if (levelData.terrain && levelData.terrain.rocks) {
                 levelData.terrain.rocks.forEach(rock => {
                     const [x, z] = rock.pos;
                     if (isValidGridPosition(x, z)) {
                         const worldPos = gridToWorld(x, z);
                         
                         // Get rock properties
                         const type = rock.type || 'boulder';
                         const size = rock.size || 'medium';
                         const material = rock.material || 'granite';
                         
                         // Rock size multipliers
                         const sizeMultipliers = {
                             small: 0.4, medium: 0.6, large: 0.9, huge: 1.3
                         };
                         const sizeMultiplier = sizeMultipliers[size] || 0.6;
                         
                         // Rock materials (colors)
                         const materialColors = {
                             granite: 0x696969, limestone: 0xF5F5DC, sandstone: 0xF4A460,
                             volcanic: 0x2F4F4F, ancient_stone: 0x708090
                         };
                         
                         // Rock types (geometries)
                         let geometry;
                         switch(type) {
                             case 'boulder':
                                 geometry = new THREE.DodecahedronGeometry(sizeMultiplier);
                                 break;
                             case 'rock_pile':
                                 geometry = new THREE.BoxGeometry(
                                     sizeMultiplier * 1.5, 
                                     sizeMultiplier * 0.8, 
                                     sizeMultiplier * 1.2
                                 );
                                 break;
                             case 'rock_formation':
                                 geometry = new THREE.ConeGeometry(
                                     sizeMultiplier * 0.8, 
                                     sizeMultiplier * 2, 
                                     8
                                 );
                                 break;
                             default:
                                 geometry = new THREE.DodecahedronGeometry(sizeMultiplier);
                         }
                         
                         const rockMaterial = new THREE.MeshLambertMaterial({ 
                             color: materialColors[material] || 0x696969 
                         });
                         const rockMesh = new THREE.Mesh(geometry, rockMaterial);
                         
                         // Position rocks slightly above ground
                         const heightOffset = type === 'rock_formation' ? sizeMultiplier : sizeMultiplier * 0.5;
                         rockMesh.position.set(worldPos.x, heightOffset, worldPos.z);
                         rockMesh.castShadow = true;
                         rockMesh.receiveShadow = true;
                         
                         // Add slight random rotation for variety
                         rockMesh.rotation.y = Math.random() * Math.PI * 2;
                         
                         world.add(rockMesh);
                         setGridOccupied(x, z, true);
                     }
                 });
             }
         }
        
                 function createWater() {
             // Iterate over loaded water areas
             if (levelData.terrain && levelData.terrain.water && levelData.terrain.water.areas) {
                 levelData.terrain.water.areas.forEach(area => {
                     const waterType = area.type || 'pond';
                     const properties = area.properties || {};
                     
                     // Water appearance based on properties
                     let waterColor = 0x1E90FF; // default blue
                     let opacity = 0.8;
                     
                     if (properties.clarity === 'murky') {
                         waterColor = 0x4682B4; // darker blue
                         opacity = 0.9;
                     }
                     if (properties.depth === 'deep') {
                         waterColor = 0x000080; // navy blue
                         opacity = 0.95;
                     }
                     if (properties.temperature === 'cold') {
                         waterColor = 0x87CEEB; // sky blue
                     }
                     
                     // Create water tiles
                     area.tiles.forEach(tile => {
                         const [x, z] = tile;
                         if (isValidGridPosition(x, z)) {
                             const worldPos = gridToWorld(x, z);
                             
                             const waterGeometry = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
                             const waterMaterial = new THREE.MeshLambertMaterial({
                                 color: waterColor,
                                 transparent: true,
                                 opacity: opacity
                             });
                             const water = new THREE.Mesh(waterGeometry, waterMaterial);
                             water.rotation.x = -Math.PI / 2;
                             water.position.set(worldPos.x, 0.02, worldPos.z);
                             
                             // Add a slight random Y variation for more natural look
                             water.position.y += (Math.random() - 0.5) * 0.01;
                             
                             world.add(water);
                             setGridOccupied(x, z, true);
                         }
                     });
                     
                     console.log(`🌊 Created ${area.name || waterType}: ${area.description || 'Water area'}`);
                 });
             }
         }
        
                 function createPushableBox() {
             if (!levelData.items || !levelData.items.containers || levelData.items.containers.length === 0) return;

             const boxData = levelData.items.containers[0]; // Get first container
             const [x, z] = boxData.pos;
             boxGridPos = { x, z }; // Initialize boxGridPos from levelData
             const boxWorldPos = gridToWorld(boxGridPos.x, boxGridPos.z);
             
             const properties = boxData.properties || {};
             const material = properties.material || 'wood';
             
             // Box materials and colors
             const materialColors = {
                 wood: 0x8B4513,
                 cursed_wood: 0x5D4E37,
                 metal: 0x708090,
                 stone: 0x696969
             };
             
             const boxGeometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
             const boxMaterial = new THREE.MeshLambertMaterial({
                 color: materialColors[material] || 0x8B4513,
                 transparent: true,
                 opacity: 0.9
             });
             pushableBox = new THREE.Mesh(boxGeometry, boxMaterial);
             pushableBox.position.set(boxWorldPos.x, 0.9, boxWorldPos.z);
             pushableBox.castShadow = true;
             pushableBox.receiveShadow = true;

             // Add decorative elements based on material
             if (material === 'cursed_wood') {
                 // Add glowing edges for cursed wood
                 const edgeMaterial = new THREE.MeshLambertMaterial({ 
                     color: 0x4B0082,
                     emissive: 0x2F004F
                 });
                 
                 for (let i = 0; i < 8; i++) {
                     const corner = new THREE.Mesh(
                         new THREE.SphereGeometry(0.08),
                         edgeMaterial
                     );
                     const cornerX = (i & 1) ? 0.8 : -0.8;
                     const cornerY = (i & 2) ? 0.8 : -0.8;
                     const cornerZ = (i & 4) ? 0.8 : -0.8;
                     corner.position.set(cornerX, cornerY, cornerZ);
                     pushableBox.add(corner);
                 }
             } else {
                 // Regular material corners
                 const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                 
                 for (let i = 0; i < 8; i++) {
                     const corner = new THREE.Mesh(
                         new THREE.SphereGeometry(0.08),
                         edgeMaterial
                     );
                     const cornerX = (i & 1) ? 0.8 : -0.8;
                     const cornerY = (i & 2) ? 0.8 : -0.8;
                     const cornerZ = (i & 4) ? 0.8 : -0.8;
                     corner.position.set(cornerX, cornerY, cornerZ);
                     pushableBox.add(corner);
                 }
             }

             world.add(pushableBox);
             setGridOccupied(boxGridPos.x, boxGridPos.z, true);
             
             console.log(`📦 Created ${boxData.type}: ${boxData.description || 'A mysterious box'}`);
         }
        
                 function createTorch() {
             if (!levelData.items || !levelData.items.light_sources || levelData.items.light_sources.length === 0) return;

             const torchData = levelData.items.light_sources[0]; // Get first light source
             const [x, z] = torchData.pos;
             const torchPos = { x, z };
             const torchWorldPos = gridToWorld(torchPos.x, torchPos.z);
             
             const properties = torchData.properties || {};

             if (isValidGridPosition(torchPos.x, torchPos.z)) {
                 const baseGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5);
                 const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                 const torchBase = new THREE.Mesh(baseGeometry, baseMaterial);
                 torchBase.position.set(torchWorldPos.x, 0.75, torchWorldPos.z);
                 torchBase.castShadow = true;
                 world.add(torchBase);

                 // Create flame if torch is lit
                 let flame = null;
                 if (properties.lit !== false) { // Default to lit
                     const flameGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                     
                     // Parse color from hex string or use default
                     let flameColor = 0xff4500;
                     if (properties.color) {
                         const colorStr = properties.color.replace('#', '');
                         flameColor = parseInt(colorStr, 16);
                     }
                     
                     const flameMaterial = new THREE.MeshLambertMaterial({
                         color: flameColor,
                         transparent: true,
                         opacity: properties.brightness || 0.8
                     });
                     flame = new THREE.Mesh(flameGeometry, flameMaterial);
                     flame.position.set(torchWorldPos.x, 1.8, torchWorldPos.z);
                     flame.scale.y = 1.3;
                     
                     // Add emissive glow if specified
                     if (properties.essence === 'fire') {
                         flameMaterial.emissive = new THREE.Color(flameColor);
                         flameMaterial.emissiveIntensity = 0.2;
                     }
                     
                     world.add(flame);
                 }

                 interactionObjects.push({
                     gridPos: torchPos,
                     type: torchData.type || 'torch',
                     essence: properties.essence || 'fire',
                     mesh: torchBase,
                     flame: flame,
                     name: torchData.type === 'torch' ? 'Ancient Torch' : 'Light Source',
                     properties: properties
                 });

                 setGridOccupied(torchPos.x, torchPos.z, true);
                 
                 console.log(`🔥 Created ${torchData.type}: ${torchData.description || 'A mysterious light source'}`);
             }
         }
        
                 function createCharacter() {
             const characterGeometry = new THREE.BoxGeometry(0.8, 1.6, 0.4);
             const characterMaterial = new THREE.MeshLambertMaterial({ 
                 color: 0xFF69B4
             });
             character = new THREE.Mesh(characterGeometry, characterMaterial);
             
             // Use spawn position from level data if available, otherwise default to origin
             if (levelData.world && levelData.world.spawn) {
                 characterGridPos = { x: levelData.world.spawn.x, z: levelData.world.spawn.z };
             } else {
                 characterGridPos = { x: 0, z: 0 };
             }
             
             const worldPos = gridToWorld(characterGridPos.x, characterGridPos.z);
             character.position.set(worldPos.x, 0.8, worldPos.z);
             characterPosition.x = worldPos.x;
             characterPosition.z = worldPos.z;
             
             character.castShadow = true;
             scene.add(character);
             
             const faceGeometry = new THREE.SphereGeometry(0.15);
             const faceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDDAA });
             const face = new THREE.Mesh(faceGeometry, faceMaterial);
             face.position.set(0, 0.3, 0.25);
             character.add(face);
             
             const eyeGeometry = new THREE.SphereGeometry(0.03);
             const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
             
             const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
             leftEye.position.set(-0.05, 0.05, 0.1);
             face.add(leftEye);
             
             const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
             rightEye.position.set(0.05, 0.05, 0.1);
             face.add(rightEye);
             
             // Position camera based on level data if available
             if (levelData.world && levelData.world.camera_start) {
                 camera.position.set(
                     levelData.world.camera_start.x, 
                     15, 
                     levelData.world.camera_start.z
                 );
                 camera.lookAt(worldPos.x, 0, worldPos.z);
             }
             
             console.log(`👤 Character spawned at grid position (${characterGridPos.x}, ${characterGridPos.z})`);
         }
        
        // Game input handlers
        function handleGameKeyDown(event) {
            if (!keys[event.code] && !keyPressed[event.code]) {
                keys[event.code] = true;
                keyPressed[event.code] = true;
                
                // Handle movement
                if (['KeyW', 'KeyS', 'KeyA', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                    handleGridMovement(event.code);
                }
                // Handle essence system
                else if (event.code === 'KeyE') {
                    handleEssenceAction();
                }
                // Handle world interaction
                else if (event.code === 'KeyF') {
                    handleWorldInteraction();
                }
            }
        }
        
        function handleGameKeyUp(event) {
            keys[event.code] = false;
            keyPressed[event.code] = false;
        }
        
        function handleGridMovement(keyCode) {
            if (isMoving) return;
            
            let newGridX = characterGridPos.x;
            let newGridZ = characterGridPos.z;
            let direction = '';
            
            switch(keyCode) {
                case 'KeyW':
                case 'ArrowUp':
                    newGridZ -= 1;
                    direction = 'up';
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    newGridZ += 1;
                    direction = 'down';
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    newGridX -= 1;
                    direction = 'left';
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    newGridX += 1;
                    direction = 'right';
                    break;
                default:
                    return;
            }
            
            // Check if there's a box in the way that needs to be pushed
            if (boxGridPos.x === newGridX && boxGridPos.z === newGridZ) {
                let boxNewX = boxGridPos.x;
                let boxNewZ = boxGridPos.z;
                
                switch(direction) {
                    case 'up': boxNewZ -= 1; break;
                    case 'down': boxNewZ += 1; break;
                    case 'left': boxNewX -= 1; break;
                    case 'right': boxNewX += 1; break;
                }
                
                if (isValidGridPosition(boxNewX, boxNewZ)) {
                    pushBox(boxNewX, boxNewZ);
                    startMovementAnimation(newGridX, newGridZ, direction);
                }
                return;
            }
            
            if (isValidGridPosition(newGridX, newGridZ)) {
                startMovementAnimation(newGridX, newGridZ, direction);
            }
        }
        
        let movementData = {
            startPos: { x: 0, z: 0 },
            endPos: { x: 0, z: 0 },
            progress: 0,
            direction: ''
        };
        
        function startMovementAnimation(newGridX, newGridZ, direction) {
            isMoving = true;
            
            movementData.startPos.x = characterPosition.x;
            movementData.startPos.z = characterPosition.z;
            movementData.endPos = gridToWorld(newGridX, newGridZ);
            movementData.progress = 0;
            movementData.direction = direction;
            
            rotateCharacterForDirection(direction);
            
            characterGridPos.x = newGridX;
            characterGridPos.z = newGridZ;
            
            updatePositionDisplay();
            updateMinimap();
        }
        
        function rotateCharacterForDirection(direction) {
            switch(direction) {
                case 'up':
                    character.rotation.y = 0;
                    break;
                case 'down':
                    character.rotation.y = Math.PI;
                    break;
                case 'left':
                    character.rotation.y = Math.PI / 2;
                    break;
                case 'right':
                    character.rotation.y = -Math.PI / 2;
                    break;
            }
        }
        
        function updateMovementAnimation() {
            if (!isMoving) return;
            
            movementData.progress += movementSpeed;
            
            if (movementData.progress >= 1) {
                movementData.progress = 1;
                isMoving = false;
            }
            
            const t = easeInOutCubic(movementData.progress);
            characterPosition.x = lerp(movementData.startPos.x, movementData.endPos.x, t);
            characterPosition.z = lerp(movementData.startPos.z, movementData.endPos.z, t);
            
            character.position.x = characterPosition.x;
            character.position.z = characterPosition.z;
            
            camera.position.x = characterPosition.x;
            camera.position.z = characterPosition.z + 8;
            camera.lookAt(characterPosition.x, 0, characterPosition.z);
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function pushBox(newX, newZ) {
            setGridOccupied(boxGridPos.x, boxGridPos.z, false);
            
            boxGridPos.x = newX;
            boxGridPos.z = newZ;
            
            setGridOccupied(newX, newZ, true);
            
            const newWorldPos = gridToWorld(newX, newZ);
            pushableBox.position.x = newWorldPos.x;
            pushableBox.position.z = newWorldPos.z;
            
            updateMinimap();
        }
        
        function handleEssenceAction() {
            if (playerEssence === null) {
                getEssenceFromObject();
            } else {
                transferEssenceToBox();
            }
        }
        
        function handleWorldInteraction() {
            console.log("World interaction - coming soon!");
        }
        
        function getEssenceFromObject() {
            const facingPos = getFacingPosition();
            
            const obj = interactionObjects.find(o => 
                o.gridPos.x === facingPos.x && o.gridPos.z === facingPos.z
            );
            
            if (obj && obj.essence) {
                playerEssence = obj.essence;
                updateEssenceDisplay();
                
                if (obj.flame) {
                    obj.flame.material.opacity = 0.4;
                }
                
                console.log(`Collected ${obj.essence} essence from ${obj.name}!`);
            }
        }
        
        function transferEssenceToBox() {
            if (isNextToBox()) {
                boxEssence = playerEssence;
                playerEssence = null;
                updateEssenceDisplay();
                updateBoxAppearance();
                
                console.log(`Transferred ${boxEssence} essence to box!`);
            }
        }
        
        function getFacingPosition() {
            const adjacentPositions = [
                { x: characterGridPos.x, z: characterGridPos.z - 1 },
                { x: characterGridPos.x, z: characterGridPos.z + 1 },
                { x: characterGridPos.x - 1, z: characterGridPos.z },
                { x: characterGridPos.x + 1, z: characterGridPos.z }
            ];
            
            for (let pos of adjacentPositions) {
                const obj = interactionObjects.find(o => 
                    o.gridPos.x === pos.x && o.gridPos.z === pos.z
                );
                if (obj) return pos;
            }
            
            return { x: characterGridPos.x, z: characterGridPos.z - 1 };
        }
        
        function isNextToBox() {
            const dx = Math.abs(characterGridPos.x - boxGridPos.x);
            const dz = Math.abs(characterGridPos.z - boxGridPos.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }
        
        function updateEssenceDisplay() {
            const essenceDisplay = document.getElementById('essence-display');
            if (essenceDisplay) {
                if (playerEssence) {
                    const essenceEmoji = getEssenceEmoji(playerEssence);
                    essenceDisplay.textContent = `🔮 Essence: ${essenceEmoji} ${capitalizeFirst(playerEssence)}`;
                } else {
                    essenceDisplay.textContent = '🔮 Essence: None';
                }
            }
        }
        
        function updateBoxAppearance() {
            if (boxEssence === 'fire') {
                pushableBox.material.color.setHex(0xff4500);
                pushableBox.material.emissive.setHex(0x330000);
            } else {
                pushableBox.material.color.setHex(0x8B4513);
                pushableBox.material.emissive.setHex(0x000000);
            }
        }
        
        function getEssenceEmoji(essence) {
            const emojis = {
                'fire': '🔥',
                'wind': '💨',
                'cannon': '💣',
                'steel': '🛡️'
            };
            return emojis[essence] || '🔮';
        }
        
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        function updatePositionDisplay() {
            const positionDisplay = document.querySelector('#gameContainer .game-ui div:nth-child(3)');
            if (positionDisplay) {
                positionDisplay.textContent = `📍 Grid: (${characterGridPos.x}, ${characterGridPos.z})`;
            }
        }
        
        function initMinimap() {
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');
            updateMinimap();
        }
        
        function updateMinimap() {
            const canvas = minimapCanvas;
            const ctx = minimapCtx;
            const size = 140;
            const viewRadius = 8;
            
            ctx.clearRect(0, 0, size, size);
            
            ctx.fillStyle = 'rgba(26, 47, 10, 0.5)';
            ctx.fillRect(0, 0, size, size);
            
            const gridCount = (viewRadius * 2 + 1);
            const tileSize = Math.floor(size / gridCount);
            const totalGridSize = tileSize * gridCount;
            const offset = (size - totalGridSize) / 2;
            
            const playerX = characterGridPos.x;
            const playerZ = characterGridPos.z;
            
            for (let x = playerX - viewRadius; x <= playerX + viewRadius; x++) {
                for (let z = playerZ - viewRadius; z <= playerZ + viewRadius; z++) {
                    const screenX = offset + (x - (playerX - viewRadius)) * tileSize;
                    const screenZ = offset + (z - (playerZ - viewRadius)) * tileSize;
                    
                    const key = `${x},${z}`;
                    const isOccupied = gridMap[key];
                    const isOutOfBounds = x < -HALF_GRID || x > HALF_GRID || z < -HALF_GRID || z > HALF_GRID;
                    
                    let color;
                    if (isOutOfBounds) {
                        color = 'rgba(26, 47, 10, 0.8)';
                    } else if (isOccupied) {
                        if (isWaterTile(x, z)) {
                            color = '#1E90FF';
                        } else if (isTreeTile(x, z)) {
                            color = '#2d5016';
                        } else {
                            color = '#555555';
                        }
                    } else {
                        const isEvenTile = (x + z) % 2 === 0;
                        color = isEvenTile ? '#4a7c1e' : '#486b1d';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(screenX, screenZ, tileSize, tileSize);
                    
                    if (!isOutOfBounds) {
                        ctx.strokeStyle = 'rgba(61, 105, 25, 0.4)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(screenX, screenZ, tileSize, tileSize);
                    }
                }
            }
            
            // Draw box if in view
            if (Math.abs(boxGridPos.x - playerX) <= viewRadius && Math.abs(boxGridPos.z - playerZ) <= viewRadius) {
                const boxScreenX = offset + (boxGridPos.x - (playerX - viewRadius)) * tileSize;
                const boxScreenZ = offset + (boxGridPos.z - (playerZ - viewRadius)) * tileSize;
                
                let boxColor = '#8B4513';
                if (boxEssence === 'fire') {
                    boxColor = '#ff4500';
                } else if (boxEssence === 'wind') {
                    boxColor = '#87CEEB';
                } else if (boxEssence === 'cannon') {
                    boxColor = '#2F4F4F';
                } else if (boxEssence === 'steel') {
                    boxColor = '#C0C0C0';
                }
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(boxScreenX - 1, boxScreenZ - 1, tileSize + 2, tileSize + 2);
                
                ctx.fillStyle = boxColor;
                ctx.fillRect(boxScreenX, boxScreenZ, tileSize, tileSize);
            }
            
            // Draw player (perfectly centered)
            const playerScreenX = offset + viewRadius * tileSize;
            const playerScreenZ = offset + viewRadius * tileSize;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(playerScreenX - 1, playerScreenZ - 1, tileSize + 2, tileSize + 2);
            
            ctx.fillStyle = '#FF69B4';
            ctx.fillRect(playerScreenX, playerScreenZ, tileSize, tileSize);
            
            // Draw essence objects
            interactionObjects.forEach(obj => {
                if (Math.abs(obj.gridPos.x - playerX) <= viewRadius && Math.abs(obj.gridPos.z - playerZ) <= viewRadius) {
                    const objScreenX = offset + (obj.gridPos.x - (playerX - viewRadius)) * tileSize;
                    const objScreenZ = offset + (obj.gridPos.z - (playerZ - viewRadius)) * tileSize;
                    
                    let objColor = '#ff4500';
                    if (obj.type === 'torch') {
                        objColor = playerEssence === obj.essence ? '#cc3300' : '#ff4500';
                    }
                    
                    ctx.fillStyle = objColor;
                    ctx.fillRect(objScreenX + 1, objScreenZ + 1, tileSize - 2, tileSize - 2);
                }
            });
        }
        
                 function isWaterTile(x, z) {
             // Check against loaded water tiles from all areas
             if (!levelData.terrain || !levelData.terrain.water || !levelData.terrain.water.areas) {
                 return false;
             }
             
             return levelData.terrain.water.areas.some(area => {
                 return area.tiles.some(tile => {
                     const [tileX, tileZ] = tile;
                     return tileX === x && tileZ === z;
                 });
             });
         }
         
         function isTreeTile(x, z) {
             // Check against loaded tree positions
             if (!levelData.terrain || !levelData.terrain.trees) {
                 return false;
             }
             
             return levelData.terrain.trees.some(tree => {
                 const [treeX, treeZ] = tree.pos;
                 return treeX === x && treeZ === z;
             });
         }
        
        function updateCharacterAnimations() {
            if (!isMoving) {
                character.position.y = 0.8 + Math.sin(Date.now() * 0.003) * 0.02;
            } else {
                character.position.y = 0.8 + Math.sin(Date.now() * 0.02) * 0.1;
            }
        }
        
                 // ==========================================
         // PERFORMANCE MONITORING
         // ==========================================
         
         // Frame rate monitoring (from the guide)
         let perfLast = performance.now();
         let perfAcc = 0;
         let perfFrames = 0;
         let fpsDisplay = null;
         
         // Create FPS display element
         function createFPSDisplay() {
             if (!fpsDisplay) {
                 fpsDisplay = document.createElement('div');
                 fpsDisplay.style.cssText = `
                     position: fixed;
                     top: 10px;
                     left: 10px;
                     background: rgba(0,0,0,0.8);
                     color: #00ff00;
                     padding: 5px 10px;
                     font-family: monospace;
                     font-size: 14px;
                     border-radius: 4px;
                     z-index: 10000;
                     pointer-events: none;
                 `;
                 document.body.appendChild(fpsDisplay);
             }
         }
         
         // Update FPS counter every second
         setInterval(() => {
             if (gameState === 'game' && perfFrames > 0) {
                 const fps = Math.round(perfFrames * 1000 / perfAcc);
                 console.log(`🎯 Game FPS: ${fps}`);
                 
                 if (fpsDisplay) {
                     fpsDisplay.textContent = `FPS: ${fps}`;
                     fpsDisplay.style.color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffaa00' : '#ff0000';
                 }
             }
             perfFrames = 0;
             perfAcc = 0;
         }, 1000);

         function animate() {
             if (gameState !== 'game') return;
             
             // Performance tracking
             const now = performance.now();
             const dt = now - perfLast;
             perfLast = now;
             perfAcc += dt;
             perfFrames++;
             
             // Show FPS display in development mode or if performance monitoring is needed
             const isDevMode = window.location.protocol === 'file:' || window.location.hostname === 'localhost';
             if ((isDevMode || perfFrames % 60 === 0) && !fpsDisplay) {
                 createFPSDisplay();
             }
             
             requestAnimationFrame(animate);
            
            updateMovementAnimation();
            updateCharacterAnimations();
            
            // Animate water
            const water = world.children.find(child => 
                child.material && child.material.color && 
                child.material.color.getHex() === 0x1E90FF
            );
            if (water) {
                water.material.opacity = 0.7 + Math.sin(Date.now() * 0.003) * 0.1;
            }
            
            // Animate trees
            world.children.forEach(child => {
                if (child.material && child.material.color && 
                    child.material.color.getHex() === 0x228B22) {
                    child.rotation.z = Math.sin(Date.now() * 0.002 + child.position.x) * 0.05;
                }
            });
            
            // Animate torch flames
            interactionObjects.forEach(obj => {
                if (obj.type === 'torch' && obj.flame) {
                    obj.flame.scale.y = 1.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    obj.flame.rotation.z = Math.sin(Date.now() * 0.008) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
                 // Optimized canvas resize with device pixel ratio handling
         function resizeCanvas() {
             if (!gameInitialized || !renderer || !camera) return;
             
             const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap pixel ratio for performance
             const width = Math.floor(window.innerWidth * dpr);
             const height = Math.floor(window.innerHeight * dpr);
             
             // Only resize if dimensions actually changed
             const canvas = renderer.domElement;
             if (canvas.width !== width || canvas.height !== height) {
                 // Update camera aspect ratio
                 const aspect = window.innerWidth / window.innerHeight;
                 const frustumSize = 20;
                 camera.left = frustumSize * aspect / -2;
                 camera.right = frustumSize * aspect / 2;
                 camera.top = frustumSize / 2;
                 camera.bottom = frustumSize / -2;
                 camera.updateProjectionMatrix();
                 
                 // Update renderer size
                 renderer.setSize(window.innerWidth, window.innerHeight);
                 renderer.setPixelRatio(dpr);
                 
                 console.log(`🖼️  Canvas resized: ${window.innerWidth}x${window.innerHeight} (${dpr}x DPR)`);
             }
         }

         // Handle window resize with debouncing
         let resizeTimeout;
         window.addEventListener('resize', () => {
             clearTimeout(resizeTimeout);
             resizeTimeout = setTimeout(resizeCanvas, 16); // ~60fps debouncing
         });
        
        // ==========================================
        // NOTIFICATION SYSTEM
        // ==========================================
        
        function showNotification(message, duration = 3000) {
            // Remove existing notification if present
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            // Add to document
            document.body.appendChild(notification);
            
            // Animate in
            requestAnimationFrame(() => {
                notification.classList.add('show');
            });
            
            // Auto-remove after duration
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('fade-out');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, duration);
        }
        
        // ==========================================
        // ELECTRON API INTEGRATION
        // ==========================================
        
        // Listen for menu bar toggle events from Electron main process
        if (window.electronAPI) {
            window.electronAPI.onMenuBarToggled((event, data) => {
                console.log('🔧 Menu bar toggled:', data.message);
                showNotification(`🔧 ${data.message}`);
            });
        }
        
        // Ensure smooth loading
        document.body.style.opacity = '1';

                 // Function to load level data from a JSON file
         async function loadLevelData(levelFileName) {
             try {
                 // Convert .cfg extension to .json for backwards compatibility
                 const jsonFileName = levelFileName.replace('.cfg', '.json');
                 const response = await fetch(`scripts/levels/${jsonFileName}`);
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 const jsonData = await response.json();
                 
                 console.log(`✅ Loaded level data from ${jsonFileName}:`, jsonData.meta);
                 console.log(`📍 Level: "${jsonData.meta.name}" - ${jsonData.meta.description}`);
                 return jsonData;
             } catch (error) {
                 console.error(`❌ Failed to load level data from ${levelFileName}:`, error);
                 return {}; // Return empty data on error
             }
         }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; 
                   img-src 'self' data:; 
                   style-src 'self' 'unsafe-inline'; 
                   media-src 'self'; 
                   connect-src 'self'; 
                   frame-ancestors 'none'; 
                   object-src 'none';">
    <title>Drowned Heart - A Cursed Tale of Love and Betrayal</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #0a1428;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* =================
           MENU STYLES 
           ================= */
        
        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a1428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 1;
            transition: opacity 1.5s ease-out;
        }
        
        .splash-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .splash-logo {
            max-width: 600px;
            width: 90%;
            height: auto;
            margin-bottom: 3rem;
            filter: drop-shadow(0 0 20px rgba(135, 206, 235, 0.6));
            animation: 
                logoGlow 4s ease-in-out infinite alternate,
                logoFloat 6s ease-in-out infinite,
                logoSway 8s ease-in-out infinite alternate;
        }
        
        @keyframes logoGlow {
            from { 
                filter: drop-shadow(0 0 20px rgba(135, 206, 235, 0.6));
            }
            to { 
                filter: drop-shadow(0 0 30px rgba(135, 206, 235, 0.9)) drop-shadow(0 0 60px rgba(70, 130, 180, 0.4));
            }
        }
        
        @keyframes logoFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px);
            }
            25% { 
                transform: translateY(-8px) translateX(2px);
            }
            50% { 
                transform: translateY(-12px) translateX(0px);
            }
            75% { 
                transform: translateY(-5px) translateX(-2px);
            }
        }
        
        @keyframes logoSway {
            0%, 100% { 
                transform: rotate(0deg) scale(1);
            }
            50% { 
                transform: rotate(1deg) scale(1.02);
            }
        }
        
        .splash-prompt {
            font-size: 1.4rem;
            color: #F4A460;
            text-shadow: 2px 2px 0px #1a365d;
            animation: promptPulse 2s ease-in-out infinite;
            font-style: italic;
            font-family: 'Georgia', serif;
        }
        
        @keyframes promptPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes subtleShimmer {
            0% { 
                filter: brightness(1.0) hue-rotate(0deg);
            }
            50% { 
                filter: brightness(1.1) hue-rotate(5deg);
            }
            100% { 
                filter: brightness(1.05) hue-rotate(-3deg);
            }
        }
        
        /* Main Menu - initially hidden */
        .main-menu {
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s ease-out;
            transition-delay: 0.5s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100%;
            position: relative;
            z-index: 10;
        }
        
        .main-menu.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .main-menu.hidden {
            display: none;
        }
        
        /* WebGL Shader Canvas */
        #shaderCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0;
            transition: opacity 2s ease-in;
        }
        
        #shaderCanvas.show {
            opacity: 0.8;
        }
        
        #shaderCanvas.hidden {
            opacity: 0;
        }
        
        /* Main menu logo */
        .main-logo {
            max-width: 400px;
            width: 70%;
            height: auto;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.5));
            animation: 
                mainLogoGlow 4s ease-in-out infinite alternate,
                mainLogoFloat 7s ease-in-out infinite,
                mainLogoBreath 5s ease-in-out infinite alternate;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .main-logo:hover {
            animation-play-state: paused;
            transform: scale(1.05) translateY(-3px);
            filter: drop-shadow(0 0 30px rgba(135, 206, 235, 0.8)) drop-shadow(0 0 60px rgba(70, 130, 180, 0.4));
        }
        
        @keyframes mainLogoGlow {
            from { 
                filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.5));
            }
            to { 
                filter: drop-shadow(0 0 25px rgba(135, 206, 235, 0.8)) drop-shadow(0 0 50px rgba(70, 130, 180, 0.3));
            }
        }
        
        @keyframes mainLogoFloat {
            0%, 100% { 
                transform: translateY(0px) translateX(0px);
            }
            33% { 
                transform: translateY(-6px) translateX(1px);
            }
            66% { 
                transform: translateY(-3px) translateX(-1px);
            }
        }
        
        @keyframes mainLogoBreath {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
            }
            50% { 
                transform: scale(1.01) rotate(0.5deg);
            }
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #F4A460;
            text-shadow: 2px 2px 0px #1a365d;
            margin-bottom: 1.5rem;
            text-align: center;
            font-style: italic;
            font-family: 'Georgia', serif;
            opacity: 0.9;
        }
        
        /* Menu container - simplified */
        .menu-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
        }
        
        /* Menu buttons */
        .menu-item {
            display: block;
            width: 320px;
            padding: 18px 35px;
            margin: 0;
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            color: #F4A460;
            text-decoration: none;
            text-align: center;
            font-size: 1.4rem;
            font-weight: bold;
            border: 3px solid #4682B4;
            border-radius: 12px;
            text-shadow: 2px 2px 0px #1a365d;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            font-family: 'Georgia', serif;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 100;
        }
        
        .menu-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(135, 206, 235, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .menu-item:hover {
            background: linear-gradient(135deg, #2c5282, #4682B4);
            box-shadow: 0 6px 20px rgba(135, 206, 235, 0.4);
            transform: translateY(-3px);
            border-color: #87CEEB;
            color: #87CEEB;
        }
        
        .menu-item:hover:before {
            left: 100%;
        }
        
        .menu-item:active {
            transform: translateY(0px);
            box-shadow: 0 0 10px rgba(135, 206, 235, 0.4);
        }
        
        /* Special styling for different menu items */
        .menu-item.start-game {
            background: linear-gradient(135deg, #4682B4, #87CEEB);
            animation: pulse 2s infinite;
            color: #ffffff;
            font-weight: bolder;
            text-shadow: 
                2px 2px 0px #1a365d,
                0px 0px 10px rgba(26, 54, 93, 0.8);
            box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4);
            transform: scale(1.05);
        }
        
        @keyframes pulse {
            0% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 0 rgba(135, 206, 235, 0.7);
            }
            70% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 15px rgba(135, 206, 235, 0);
            }
            100% { 
                box-shadow: 0 6px 20px rgba(70, 130, 180, 0.4), 0 0 0 0 rgba(135, 206, 235, 0);
            }
        }
        
        .menu-item.start-game:hover {
            background: linear-gradient(135deg, #87CEEB, #B0E0E6);
            color: #ffffff;
            text-shadow: 
                2px 2px 0px #1a365d,
                0px 0px 15px rgba(26, 54, 93, 0.9);
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(135, 206, 235, 0.6);
        }
        
        /* Footer */
        .footer {
            position: absolute;
            bottom: 20px;
            color: #F4A460;
            font-size: 0.9rem;
            text-shadow: 1px 1px 0px #1a365d;
            font-style: italic;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #4682B4;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(135, 206, 235, 0.5);
            scrollbar-width: thin;
            scrollbar-color: #4682B4 rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            color: #87CEEB;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #1a365d;
            font-family: 'Georgia', serif;
        }
        
        .modal-body {
            color: #F4A460;
            font-size: 1.1rem;
            line-height: 1.6;
            text-shadow: 1px 1px 0px #1a365d;
        }
        
        .modal-body h3 {
            color: #87CEEB;
            margin-top: 25px;
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }
        
        .modal-body ul {
            padding-left: 20px;
        }
        
        .modal-body li {
            margin-bottom: 8px;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #87CEEB;
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-btn:hover {
            color: #F4A460;
        }
        
        .key-combo {
            background: rgba(70, 130, 180, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #4682B4;
            font-family: 'Courier New', monospace;
            color: #87CEEB;
        }
        
        /* Webkit scrollbar styling */
        .modal-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .modal-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(70, 130, 180, 0.2);
        }
        
        .modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #4682B4, #2c5282);
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 4px rgba(135, 206, 235, 0.3);
        }
        
        .modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #87CEEB, #4682B4);
            box-shadow: 0 2px 8px rgba(135, 206, 235, 0.5);
        }
        
        .modal-content::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, #87CEEB, #5a9fd4);
        }
        
        .modal-content::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* =================
           GAME STYLES 
           ================= */
        
        .game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            background: #1a2f0a;
            z-index: 5;
        }
        
        .game-container.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .game-canvas {
            display: block;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #8B4513;
            min-width: 120px;
        }
        
        .game-ui div {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 0px #000, 0px 0px 10px rgba(255, 215, 0, 0.3);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #8B4513;
        }
        
        .game-minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #8B4513;
            border-radius: 10px;
            z-index: 100;
            padding: 5px;
            box-sizing: border-box;
        }
        
        .minimap-title {
            color: #FFD700;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 0 5px 0;
            text-shadow: 1px 1px 0px #000;
            margin: 0;
        }
        
        #minimapCanvas {
            display: block;
            margin: 0 auto;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Back to menu button */
        .back-to-menu {
            position: absolute;
            top: 20px;
            right: 190px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            color: #F4A460;
            border: 2px solid #4682B4;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 12px;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .back-to-menu:hover {
            background: linear-gradient(135deg, #2c5282, #4682B4);
            color: #87CEEB;
            transform: translateY(-2px);
        }
        
        /* Notification system for menu bar toggle */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #87CEEB;
            padding: 12px 24px;
            border-radius: 8px;
            border: 2px solid #4682B4;
            font-family: 'Georgia', serif;
            font-size: 14px;
            z-index: 9999;
            opacity: 0;
            transform: translateX(-50%) translateY(-10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .notification.fade-out {
            opacity: 0;
            transform: translateX(-50%) translateY(-10px);
        }
        
        /* Responsive adjustments */
        @media (max-height: 700px) {
            .main-logo {
                max-width: 300px;
                width: 60%;
                margin-bottom: 0.5rem;
            }
            .subtitle {
                font-size: 1rem;
                margin-bottom: 1rem;
            }
            .menu-container {
                gap: 15px;
            }
            .menu-item {
                padding: 15px 30px;
                font-size: 1.3rem;
            }
        }
        
        @media (max-width: 480px) {
            .menu-item {
                width: 280px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen" class="splash-screen">
        <img src="assets/img/logo.png" alt="Drowned Heart" class="splash-logo">
        <div class="splash-prompt">Press any key to start...</div>
    </div>
    
    <!-- Underwater Shader Background -->
    <canvas id="shaderCanvas"></canvas>
    
    <!-- Background Music -->
    <audio id="menuMusic" loop>
        <source src="assets/ost/menu.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Main Menu Content -->
    <div id="mainMenu" class="main-menu">
        <img src="assets/img/logo.png" alt="Drowned Heart" class="main-logo" onclick="startGame()" title="Click to start game">
        <div class="subtitle">A Cursed Tale of Love and Betrayal</div>
    
        <div class="menu-container">
            <a href="#" class="menu-item start-game" onclick="startGame()">
                ⚔️ START GAME
            </a>
            
            <a href="#" class="menu-item" onclick="showLoadGame()">
                📜 LOAD GAME
            </a>
            
            <a href="#" class="menu-item" onclick="showOptions()">
                ⚙️ OPTIONS
            </a>
            
            <a href="#" class="menu-item" onclick="confirmExit()">
                🚪 QUIT GAME
            </a>
        </div>
    </div>
    
    <!-- Game Container -->
    <div id="gameContainer" class="game-container">
        <canvas id="gameCanvas" class="game-canvas"></canvas>
        <button class="back-to-menu" onclick="backToMenu()">🏴‍☠️ Back to Menu</button>
        <div class="game-ui">
            <div>♥♥♥ Health</div>
            <div>💎 Rupees: 0</div>
            <div>📍 Position: (0, 0)</div>
            <div id="essence-display">🔮 Essence: None</div>
        </div>
        <div class="game-minimap">
            <div class="minimap-title">Map</div>
            <canvas id="minimapCanvas" width="140" height="140"></canvas>
        </div>
        <div class="game-controls">
            🎮 WASD or Arrow Keys to move<br>
            🔮 E - Get/Transfer Essence<br>
            🤝 F - Interact with Objects<br>
            📦 Push box by walking into it
        </div>
    </div>
    
    <!-- Modal for Options -->
    <div id="optionsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('optionsModal')">&times;</span>
            <div class="modal-header">⚙️ Ship Options</div>
            <div class="modal-body">
                <h3>🎮 Graphics Settings</h3>
                <ul>
                    <li><strong>Shader Quality:</strong> High (Underwater Caustics)</li>
                    <li><strong>Resolution:</strong> Adaptive</li>
                    <li><strong>Frame Rate:</strong> 60 FPS Target</li>
                </ul>
                
                <h3>🔊 Audio Settings</h3>
                <ul>
                    <li><strong>Background Music:</strong> Enabled</li>
                    <li><strong>Sound Effects:</strong> Enabled</li>
                    <li><strong>Volume:</strong> 50%</li>
                </ul>
                
                <h3>🗺️ Controls</h3>
                <ul>
                    <li><span class="key-combo">WASD</span> or <span class="key-combo">Arrow Keys</span> - Navigate the cursed island</li>
                    <li><span class="key-combo">E</span> - Absorb/Transfer amulet essence</li>
                    <li><span class="key-combo">F</span> - Interact with objects</li>
                    <li><span class="key-combo">Mouse</span> - Menu navigation</li>
                </ul>
                
                <h3>⚡ Gameplay</h3>
                <ul>
                    <li><strong>Difficulty:</strong> Treacherous Waters</li>
                    <li><strong>Auto-save:</strong> Captain's Log Enabled</li>
                    <li><strong>Tutorial:</strong> Available</li>
                </ul>
                
                <p style="margin-top: 25px; font-style: italic; color: #87CEEB;">
                    "Configure your vessel for the cursed voyage ahead..."
                </p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        let gameState = 'splash'; // splash, menu, game
        let gameInitialized = false;
        
        // ==========================================
        // MENU SYSTEM
        // ==========================================
        
        // Audio system
        const menuMusic = document.getElementById('menuMusic');
        let volume = 0.5;
        let splashMode = true;
        
        // Performance settings
        const ENABLE_SHADER = true; // Set to false to disable shader for better performance
        const SHADER_QUALITY = 'medium'; // 'low', 'medium', 'high'
        
                 // WebGL Shader Setup
         let canvas, gl, program, startTime;
         
         // Comprehensive WebGL diagnostic function
         function diagnoseWebGLIssues() {
             console.log('🔍 === WebGL Diagnostic Start ===');
             
             // Test basic canvas creation
             const testCanvas = document.createElement('canvas');
             console.log('✅ Canvas element created successfully');
             
             // Test different context types
             const contextTypes = ['webgl2', 'webgl', 'experimental-webgl'];
             const contextAttributes = {
                 antialias: false,
                 alpha: false,
                 depth: true,
                 stencil: false,
                 preserveDrawingBuffer: false,
                 desynchronized: true,
                 powerPreference: 'high-performance',
                 failIfMajorPerformanceCaveat: false
             };
             
             let workingContext = null;
             for (const contextType of contextTypes) {
                 try {
                     const ctx = testCanvas.getContext(contextType, contextAttributes);
                     if (ctx) {
                         console.log(`✅ ${contextType.toUpperCase()} context created successfully`);
                         workingContext = { type: contextType, context: ctx };
                         break;
                     } else {
                         console.log(`❌ ${contextType.toUpperCase()} context creation returned null`);
                     }
                 } catch (error) {
                     console.log(`❌ ${contextType.toUpperCase()} context creation threw error:`, error);
                 }
             }
             
             if (workingContext) {
                 const gl = workingContext.context;
                 
                 // Get detailed GL info
                 console.log(`🎮 Working WebGL context: ${workingContext.type.toUpperCase()}`);
                 console.log('📊 WebGL Version:', gl.getParameter(gl.VERSION));
                 console.log('📝 GLSL Version:', gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
                 
                 // Check for debug extension
                 const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                 if (debugInfo) {
                     const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                     const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                     
                     console.log('🖥️ GPU Renderer:', renderer);
                     console.log('🏢 GPU Vendor:', vendor);
                     
                     // Detect software rendering
                     const isSoftware = renderer.includes('SwiftShader') || 
                                       renderer.includes('llvmpipe') || 
                                       renderer.includes('ANGLE (Software)') ||
                                       renderer.includes('Mesa') ||
                                       renderer.toLowerCase().includes('software');
                     
                     if (isSoftware) {
                         console.error('🚨 SOFTWARE RENDERING DETECTED!');
                         console.error('   This will cause poor performance.');
                         console.error('   Solutions:');
                         console.error('   • Update GPU drivers');
                         console.error('   • Enable hardware acceleration');
                         console.error('   • Check if running in VM/RDP');
                     } else {
                         console.log('✅ Hardware acceleration appears to be working');
                     }
                 } else {
                     console.warn('⚠️ WEBGL_debug_renderer_info extension not available');
                 }
                 
                 // Test basic operations
                 try {
                     gl.clear(gl.COLOR_BUFFER_BIT);
                     console.log('✅ Basic WebGL operations working');
                 } catch (error) {
                     console.error('❌ Basic WebGL operations failed:', error);
                 }
                 
             } else {
                 console.error('🚨 NO WEBGL CONTEXT AVAILABLE!');
                 console.error('   This means WebGL is completely disabled.');
                 console.error('   Check:');
                 console.error('   • Chrome flags: chrome://flags/#disable-webgl');
                 console.error('   • GPU blacklist status');
                 console.error('   • Hardware acceleration enabled');
                 console.error('   • Not running with --disable-gpu flag');
             }
             
             console.log('🔍 === WebGL Diagnostic End ===');
             return workingContext;
         }
         
         function initShader() {
             if (!ENABLE_SHADER) {
                 console.log('🎨 Shader disabled for performance - using solid background');
                 createFallbackBackground();
                 return;
             }
             
             // Run comprehensive diagnostics first
             const diagnosticResult = diagnoseWebGLIssues();
            
                         canvas = document.getElementById('shaderCanvas');
             
             // Optimized WebGL context creation with performance hints
             const contextAttributes = {
                 antialias: false, // Disable for better performance
                 alpha: false, // Opaque canvas for better performance
                 depth: true, // Keep depth buffer for 3D
                 stencil: false, // Disable stencil buffer for performance
                 preserveDrawingBuffer: false, // Better performance
                 desynchronized: true, // Reduce latency
                 powerPreference: 'high-performance', // Request high-performance GPU
                 failIfMajorPerformanceCaveat: false // Don't fail on performance warnings
             };
             
             gl = canvas.getContext('webgl2', contextAttributes) || 
                  canvas.getContext('webgl', contextAttributes) || 
                  canvas.getContext('experimental-webgl', contextAttributes);
            
                         if (!gl) {
                 console.log('❌ WebGL not supported, falling back to CSS background');
                 createFallbackBackground();
                 return;
             }
             
             // WebGL renderer diagnostics
             const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
             if (debugInfo) {
                 const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                 const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                 
                 console.log('🖥️  WebGL Renderer:', renderer);
                 console.log('🏢 WebGL Vendor:', vendor);
                 
                 // Check for software rendering
                 if (renderer.includes('SwiftShader') || renderer.includes('llvmpipe') || 
                     renderer.includes('ANGLE (Software)')) {
                     console.warn('⚠️  SOFTWARE RENDERING DETECTED! Performance will be poor.');
                     console.warn('   → Try updating GPU drivers or enabling hardware acceleration');
                 } else {
                     console.log('✅ Hardware acceleration active');
                 }
             }
             
             // WebGL capabilities diagnostics
             const capabilities = {
                 maxTextures: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                 maxTextureUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                 maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS),
                 maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                 maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS)
             };
             console.log('🎮 WebGL Capabilities:');
             console.table(capabilities);
             
             console.log('✅ WebGL shader initialized successfully');
            
            // Vertex shader
            const vertexShaderSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // Lightweight underwater effect shader (replaces heavy Worley noise)
            const fragmentShaderSource = `
                precision mediump float;
                uniform vec2 u_resolution;
                uniform float u_time;
                
                // Simple noise function
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }
                
                // Smooth noise
                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    
                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }
                
                // Fractal noise for water effect
                float fbm(vec2 p) {
                    float value = 0.0;
                    float freq = 1.0;
                    float amp = 0.5;
                    
                    for(int i = 0; i < 3; i++) {
                        value += amp * noise(p * freq);
                        freq *= 2.0;
                        amp *= 0.5;
                    }
                    return value;
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                    
                    // Create moving water effect
                    vec2 p = uv * 3.0 + u_time * 0.1;
                    float n1 = fbm(p + vec2(u_time * 0.05, 0.0));
                    float n2 = fbm(p + vec2(0.0, u_time * 0.08));
                    
                    // Combine noise for caustics effect
                    float caustics = n1 + n2 * 0.5;
                    caustics = smoothstep(0.3, 1.0, caustics);
                    
                    // Create underwater color gradient
                    vec3 deepBlue = vec3(0.05, 0.15, 0.3);
                    vec3 lightBlue = vec3(0.1, 0.4, 0.6);
                    
                    // Distance from center for vignette
                    float dist = length(uv - 0.5);
                    float vignette = 1.0 - smoothstep(0.3, 0.8, dist);
                    
                    // Final color
                    vec3 color = mix(deepBlue, lightBlue, caustics * vignette);
                    color += caustics * 0.3 * vignette;
                    
                    gl_FragColor = vec4(color, 0.8);
                }
            `;
            
            // Create and compile shaders
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            // Create program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return;
            }
            
            // Setup geometry (fullscreen quad)
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Start animation
            startTime = Date.now();
            resizeCanvas();
            animateShader();
        }
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function resizeCanvas() {
            if (!canvas || !gl) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        function animateShader() {
            if (!gl || !program) return;
            
            const currentTime = (Date.now() - startTime) / 1000;
            
            gl.useProgram(program);
            
            // Set uniforms
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            gl.uniform1f(timeLocation, currentTime);
            
            // Draw
            gl.clearColor(0.04, 0.08, 0.16, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(animateShader);
        }
        
        // Fallback background for when WebGL is disabled or unavailable
        function createFallbackBackground() {
            const canvas = document.getElementById('shaderCanvas');
            if (canvas) {
                // Replace canvas with CSS gradient background
                canvas.style.background = `
                    radial-gradient(ellipse at center, 
                        rgba(16, 64, 112, 0.8) 0%, 
                        rgba(8, 32, 64, 0.9) 50%, 
                        rgba(4, 16, 32, 0.95) 100%),
                    linear-gradient(45deg, 
                        rgba(10, 20, 40, 0.8) 0%, 
                        rgba(5, 30, 60, 0.8) 100%)
                `;
                canvas.style.backgroundSize = '100% 100%, 100% 100%';
                
                // Add subtle CSS animation
                canvas.style.animation = 'subtleShimmer 8s ease-in-out infinite alternate';
            }
        }

        // Initialize when page loads
        window.addEventListener('load', function() {
            // Don't initialize shader immediately to reduce initial lag
            // Shader will be initialized when transitioning to menu
            
            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Set music volume but don't start playing yet
            menuMusic.volume = volume;
        });
        
        // Performance monitoring for smooth transitions
        function logPerformance(label) {
            if (performance && performance.now) {
                console.log(`⚡ ${label}: ${performance.now().toFixed(2)}ms`);
            }
        }
        
        // Optimized splash screen transition
        function transitionToMainMenu() {
            if (!splashMode) return;
            logPerformance('Transition started');
            
            splashMode = false;
            gameState = 'menu';
            const splashScreen = document.getElementById('splashScreen');
            const mainMenu = document.getElementById('mainMenu');
            const shaderCanvas = document.getElementById('shaderCanvas');
            
            // Start the fade out immediately for smooth transition
            requestAnimationFrame(() => {
                splashScreen.classList.add('fade-out');
            });
            
            // Start music asynchronously to avoid blocking
            setTimeout(() => {
                menuMusic.volume = volume;
                menuMusic.play().catch(() => {
                    // Retry once after a short delay if needed
                    setTimeout(() => menuMusic.play().catch(() => {}), 500);
                });
            }, 100);
            
            // Initialize and activate background with optimal timing
            setTimeout(() => {
                logPerformance('Background initialization started');
                // Initialize shader or fallback if not already done
                if (!gl && ENABLE_SHADER) {
                    initShader();
                } else if (!ENABLE_SHADER) {
                    createFallbackBackground();
                }
                requestAnimationFrame(() => {
                    shaderCanvas.classList.add('show');
                    logPerformance('Background visible');
                });
            }, 300);
            
            // Show main menu with smooth timing
            setTimeout(() => {
                requestAnimationFrame(() => {
                    mainMenu.classList.add('show');
                    logPerformance('Menu visible');
                });
            }, 600);
            
            // Clean up splash screen after transition completes
            setTimeout(() => {
                if (splashScreen && splashScreen.parentNode) {
                    splashScreen.remove();
                }
            }, 1800);
        }
        
        // Modal functions
        function showLoadGame() {
            console.log('🔄 Load Game functionality pending - save system not yet implemented');
        }
        
        function showOptions() {
            document.getElementById('optionsModal').style.display = 'block';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
        
        function confirmExit() {
            if (confirm('🚪 Are you sure you want to quit the game?\n\nYour cursed voyage has only just begun...')) {
                window.close();
            }
        }
        
        // Handle clicks for audio interaction
        document.addEventListener('click', function(event) {
            // Try to start music on any click if it's not playing
            if (gameState === 'menu' && menuMusic.paused) {
                menuMusic.volume = volume;
                menuMusic.play().then(() => {
                    console.log('Music started via click');
                }).catch(error => {
                    console.log('Click music start failed:', error);
                });
            }
        });
        
        // ==========================================
        // GAME TRANSITION FUNCTIONS
        // ==========================================
        
        // Reset game state for clean restart
        function resetGameState() {
            console.log('🔄 Resetting game state...');
            
            // Reset input state
            keys = {};
            keyPressed = {};
            isMoving = false;
            
            // Reset character position and movement
            characterGridPos = { x: 0, z: 0 };
            characterPosition = { x: 0, z: 0 };
            
            // Reset essence system
            playerEssence = null;
            boxEssence = null;
            
            // Reset box position
            boxGridPos = { x: 2, z: 2 };
            
            // Reset performance monitoring
            perfLast = performance.now();
            perfAcc = 0;
            perfFrames = 0;
            
            // Remove FPS display if it exists
            const existingFpsDisplay = document.querySelector('.fps-counter');
            if (existingFpsDisplay) {
                existingFpsDisplay.remove();
                fpsDisplay = null;
            }
            
            console.log('✅ Game state reset complete');
        }
        
        function startGame() {
            console.log('Starting game...');
            gameState = 'game';
            
            // Hide menu elements
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('shaderCanvas').classList.add('hidden');
            
            // Stop menu music
            menuMusic.pause();
            
            // Show game container
            document.getElementById('gameContainer').classList.add('active');
            
            // Always reset game state when starting game (fixes control issues)
            if (gameInitialized) {
                resetGameState();
                // Re-initialize game objects to their starting positions
                if (character) {
                    const worldPos = gridToWorld(0, 0);
                    character.position.set(worldPos.x, 0.8, worldPos.z);
                    characterPosition.x = worldPos.x;
                    characterPosition.z = worldPos.z;
                    
                    // Reset camera position
                    camera.position.set(worldPos.x, 15, worldPos.z + 8);
                    camera.lookAt(worldPos.x, 0, worldPos.z);
                }
                
                // Reset pushable box position
                if (pushableBox) {
                    const boxWorldPos = gridToWorld(boxGridPos.x, boxGridPos.z);
                    pushableBox.position.set(boxWorldPos.x, 0.9, boxWorldPos.z);
                    updateBoxAppearance(); // Reset box appearance
                }
                
                // Update UI displays
                updatePositionDisplay();
                updateEssenceDisplay();
                updateMinimap();
                
                // Restart animation loop
                animate();
            }
            
            // Initialize game if not already done (first time only)
            if (!gameInitialized) {
                initializeGame();
                gameInitialized = true;
            }
        }
        
        function backToMenu() {
            console.log('Back to menu...');
            gameState = 'menu';
            
            // Clean up any lingering input states
            keys = {};
            keyPressed = {};
            isMoving = false;
            
            // Remove FPS display when leaving game
            const existingFpsDisplay = document.querySelector('.fps-counter');
            if (existingFpsDisplay) {
                existingFpsDisplay.remove();
                fpsDisplay = null;
            }
            
            // Hide game container
            document.getElementById('gameContainer').classList.remove('active');
            
            // Show menu elements
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('shaderCanvas').classList.remove('hidden');
            
            // Start menu music
            menuMusic.volume = volume;
            menuMusic.play().catch(error => {
                console.log('Failed to restart menu music:', error);
            });
            
            console.log('✅ Returned to main menu');
        }
        
        // ==========================================
        // KEYBOARD HANDLING
        // ==========================================
        
        document.addEventListener('keydown', function(event) {
            // Handle F1 key for menu bar toggle (globally)
            if (event.code === 'F1') {
                event.preventDefault(); // Prevent browser's default F1 behavior
                return; // Let Electron main process handle the actual toggle
            }
            
            if (gameState === 'splash') {
                // Any key during splash transitions to main menu
                transitionToMainMenu();
            } else if (gameState === 'menu') {
                if (event.code === 'Escape') {
                    // Handle modal closing or exit confirmation
                    const modals = document.querySelectorAll('.modal');
                    let modalOpen = false;
                    modals.forEach(modal => {
                        if (modal.style.display === 'block') {
                            modal.style.display = 'none';
                            modalOpen = true;
                        }
                    });
                    if (!modalOpen) {
                        confirmExit();
                    }
                } else if (event.code === 'Enter') {
                    startGame();
                }
            } else if (gameState === 'game') {
                if (event.code === 'Escape') {
                    backToMenu();
                } else {
                    // Let game handle other keys
                    handleGameKeyDown(event);
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if (gameState === 'game') {
                handleGameKeyUp(event);
            }
        });
        
        // ==========================================
        // GAME CODE
        // ==========================================
        
        // Game variables
        let scene, camera, renderer, character, world;
        let keys = {};
        let keyPressed = {};
        let isMoving = false;
        let movementSpeed = 0.15;
        let minimapCanvas, minimapCtx;
        
        // Box and essence system
        let pushableBox;
        let boxGridPos = { x: 2, z: 2 };
        let playerEssence = null;
        let boxEssence = null;
        let interactionObjects = [];
        
        // Grid system
        const TILE_SIZE = 2;
        const GRID_SIZE = 51;
        const HALF_GRID = Math.floor(GRID_SIZE / 2);
        
        // Character position in grid coordinates
        let characterGridPos = { x: 0, z: 0 };
        let characterPosition = { x: 0, z: 0 };
        
        // Grid occupancy map
        let gridMap = {};
        
        // Initialize grid map
        function initGridMap() {
            gridMap = {};
            for (let x = -HALF_GRID; x <= HALF_GRID; x++) {
                for (let z = -HALF_GRID; z <= HALF_GRID; z++) {
                    gridMap[`${x},${z}`] = false;
                }
            }
        }
        
        // Convert grid coordinates to world coordinates
        function gridToWorld(gridX, gridZ) {
            return {
                x: gridX * TILE_SIZE,
                z: gridZ * TILE_SIZE
            };
        }
        
        // Convert world coordinates to grid coordinates
        function worldToGrid(worldX, worldZ) {
            return {
                x: Math.round(worldX / TILE_SIZE),
                z: Math.round(worldZ / TILE_SIZE)
            };
        }
        
        // Check if a grid position is valid and not occupied
        function isValidGridPosition(gridX, gridZ) {
            const key = `${gridX},${gridZ}`;
            const withinBounds = gridX >= -HALF_GRID && gridX <= HALF_GRID && 
                                gridZ >= -HALF_GRID && gridZ <= HALF_GRID;
            
            const isBoxPosition = (gridX === boxGridPos.x && gridZ === boxGridPos.z);
            
            return withinBounds && !gridMap[key] && !isBoxPosition;
        }
        
        // Set grid position as occupied
        function setGridOccupied(gridX, gridZ, occupied = true) {
            const key = `${gridX},${gridZ}`;
            if (gridMap.hasOwnProperty(key)) {
                gridMap[key] = occupied;
            }
        }
        
                     // Initialize the game
             function initializeGame() {
                 console.log('Initializing Three.js game...');
                 
                 // WebGL capability checks before proceeding
                 const testCanvas = document.createElement('canvas');
                 const testGL = testCanvas.getContext('webgl2') || testCanvas.getContext('webgl');
                 
                 if (testGL) {
                     // Log WebGL capabilities for debugging
                     const caps = {
                         maxTexSize: testGL.getParameter(testGL.MAX_TEXTURE_SIZE),
                         maxTexUnits: testGL.getParameter(testGL.MAX_TEXTURE_IMAGE_UNITS),
                         maxVaryings: testGL.getParameter(testGL.MAX_VARYING_VECTORS) || testGL.getParameter(testGL.MAX_VARYING_COMPONENTS),
                         maxVertAttribs: testGL.getParameter(testGL.MAX_VERTEX_ATTRIBS),
                         webgl2: !!testCanvas.getContext('webgl2')
                     };
                     
                     console.log('🎮 Three.js WebGL Capabilities:');
                     console.table(caps);
                     
                     if (caps.maxTexSize < 1024) {
                         console.warn('⚠️  Very low texture size limit detected:', caps.maxTexSize);
                     }
                     
                     if (caps.webgl2) {
                         console.log('✅ WebGL 2.0 support detected');
                     } else {
                         console.log('ℹ️  Using WebGL 1.0 (WebGL 2.0 not available)');
                     }
                 }
                 
                 // Initialize grid system
                 initGridMap();
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2f0a);
            
            // Create orthographic camera for top-down 2.5D view
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 20;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            
            // Position camera for top-down view with slight angle
            camera.position.set(0, 15, 8);
            camera.lookAt(0, 0, 0);
            
            // Create optimized renderer with performance hints
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false, // Disable for better performance - use post-processing if needed
                alpha: false, // Opaque canvas for better performance
                depth: true, // Keep depth buffer for 3D rendering
                stencil: false, // Disable stencil buffer for performance
                preserveDrawingBuffer: false, // Better performance 
                powerPreference: 'high-performance', // Request high-performance GPU
                failIfMajorPerformanceCaveat: false // Don't fail on performance warnings
            });
            
            // Set pixel ratio based on device, but cap it for performance
            const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Configure shadows with performance in mind
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Good balance of quality/performance
            
            // Additional performance optimizations
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.LinearToneMapping;
            
            setupLighting();
            createWorld();
            createCharacter();
            initMinimap();
            
            animate();
            console.log('Game initialized successfully!');
        }
        
        function setupLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light for shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }
        
        function createWorld() {
            world = new THREE.Group();
            
            createGridTerrain();
            createTrees();
            createRocks();
            createWater();
            createPushableBox();
            createTorch();
            
            scene.add(world);
        }
        
        function createGridTerrain() {
            // Create individual tiles for the grid with subtle grid lines
            const tileGeometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c1e });
            const grassMaterial2 = new THREE.MeshLambertMaterial({ color: 0x486b1d });
            
            const gridLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x3d6919, 
                transparent: true, 
                opacity: 0.4 
            });
            
            for (let gridX = -HALF_GRID; gridX <= HALF_GRID; gridX++) {
                for (let gridZ = -HALF_GRID; gridZ <= HALF_GRID; gridZ++) {
                    const worldPos = gridToWorld(gridX, gridZ);
                    
                    const isEvenTile = (gridX + gridZ) % 2 === 0;
                    const material = isEvenTile ? grassMaterial : grassMaterial2;
                    
                    const tile = new THREE.Mesh(tileGeometry, material);
                    tile.rotation.x = -Math.PI / 2;
                    tile.position.set(worldPos.x, 0, worldPos.z);
                    tile.receiveShadow = true;
                    world.add(tile);
                    
                    // Create grid outline
                    const halfTile = TILE_SIZE / 2;
                    const gridGeometry = new THREE.BufferGeometry();
                    const gridVertices = new Float32Array([
                        -halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, -halfTile,
                        halfTile, 0.002, halfTile,
                        halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, halfTile,
                        -halfTile, 0.002, -halfTile,
                    ]);
                    
                    gridGeometry.setAttribute('position', new THREE.BufferAttribute(gridVertices, 3));
                    const gridLines = new THREE.LineSegments(gridGeometry, gridLineMaterial);
                    gridLines.position.set(worldPos.x, 0, worldPos.z);
                    world.add(gridLines);
                }
            }
        }
        
        function createTrees() {
            const treeGridPositions = [
                { x: -4, z: -4 }, { x: 4, z: -4 }, { x: -4, z: 4 }, { x: 4, z: 4 },
                { x: -6, z: 0 }, { x: 6, z: 0 }, { x: 0, z: -6 }, { x: 0, z: 6 },
                { x: -10, z: -8 }, { x: 8, z: -12 }, { x: -12, z: 10 }, { x: 12, z: 8 },
                { x: -15, z: -15 }, { x: 15, z: -15 }, { x: -15, z: 15 }, { x: 15, z: 15 },
                { x: -8, z: -20 }, { x: 8, z: 20 }, { x: -20, z: 8 }, { x: 20, z: -8 },
                { x: -18, z: 0 }, { x: 18, z: 0 }, { x: 0, z: -18 }, { x: 0, z: 18 },
                { x: -22, z: -10 }, { x: 22, z: 10 }, { x: -10, z: 22 }, { x: 10, z: -22 },
                { x: -24, z: -5 }, { x: 24, z: 5 }, { x: -5, z: -24 }, { x: 5, z: 24 },
                { x: -25, z: 0 }, { x: 25, z: 0 }, { x: 0, z: -25 }, { x: 0, z: 25 },
                { x: -23, z: 17 }, { x: 23, z: -17 }, { x: -17, z: 23 }, { x: 17, z: -23 }
            ];
            
            treeGridPositions.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    // Tree trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(worldPos.x, 1, worldPos.z);
                    trunk.castShadow = true;
                    world.add(trunk);
                    
                    // Tree leaves
                    const leavesGeometry = new THREE.SphereGeometry(1.0);
                    const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(worldPos.x, 2.5, worldPos.z);
                    leaves.castShadow = true;
                    world.add(leaves);
                    
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createRocks() {
            const rockGridPositions = [
                { x: -3, z: -3 }, { x: 3, z: 3 }, { x: -3, z: 3 }, { x: 5, z: -2 },
                { x: -7, z: 2 }, { x: 9, z: -5 }, { x: -11, z: -7 }, { x: 13, z: 6 },
                { x: -16, z: 12 }, { x: 14, z: -16 }, 
                { x: -21, z: -3 }, { x: 21, z: 3 }, { x: -3, z: -21 }, { x: 3, z: 21 },
                { x: -19, z: 8 }, { x: 19, z: -8 }, { x: -8, z: 19 }, { x: 8, z: -19 },
                { x: -24, z: 12 }, { x: 24, z: -12 }
            ];
            
            rockGridPositions.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    const rockGeometry = new THREE.DodecahedronGeometry(0.6);
                    const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(worldPos.x, 0.3, worldPos.z);
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    world.add(rock);
                    
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createWater() {
            const pondTiles = [
                { x: -8, z: -8 }, { x: -7, z: -8 }, { x: -6, z: -8 },
                { x: -8, z: -7 }, { x: -7, z: -7 }, { x: -6, z: -7 },
                { x: -8, z: -6 }, { x: -7, z: -6 }, { x: -6, z: -6 }
            ];
            
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.8
            });
            
            pondTiles.forEach(gridPos => {
                if (isValidGridPosition(gridPos.x, gridPos.z)) {
                    const worldPos = gridToWorld(gridPos.x, gridPos.z);
                    
                    const waterGeometry = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
                    const water = new THREE.Mesh(waterGeometry, waterMaterial);
                    water.rotation.x = -Math.PI / 2;
                    water.position.set(worldPos.x, 0.02, worldPos.z);
                    world.add(water);
                    
                    setGridOccupied(gridPos.x, gridPos.z, true);
                }
            });
        }
        
        function createPushableBox() {
            const boxWorldPos = gridToWorld(boxGridPos.x, boxGridPos.z);
            
            const boxGeometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            const boxMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.9
            });
            pushableBox = new THREE.Mesh(boxGeometry, boxMaterial);
            pushableBox.position.set(boxWorldPos.x, 0.9, boxWorldPos.z);
            pushableBox.castShadow = true;
            pushableBox.receiveShadow = true;
            
            const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            for (let i = 0; i < 8; i++) {
                const corner = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08),
                    edgeMaterial
                );
                const x = (i & 1) ? 0.8 : -0.8;
                const y = (i & 2) ? 0.8 : -0.8;
                const z = (i & 4) ? 0.8 : -0.8;
                corner.position.set(x, y, z);
                pushableBox.add(corner);
            }
            
            world.add(pushableBox);
            setGridOccupied(boxGridPos.x, boxGridPos.z, true);
        }
        
        function createTorch() {
            const torchPos = { x: -5, z: 3 };
            const torchWorldPos = gridToWorld(torchPos.x, torchPos.z);
            
            if (isValidGridPosition(torchPos.x, torchPos.z)) {
                const baseGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const torchBase = new THREE.Mesh(baseGeometry, baseMaterial);
                torchBase.position.set(torchWorldPos.x, 0.75, torchWorldPos.z);
                torchBase.castShadow = true;
                world.add(torchBase);
                
                const flameGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const flameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4500,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.set(torchWorldPos.x, 1.8, torchWorldPos.z);
                flame.scale.y = 1.3;
                world.add(flame);
                
                interactionObjects.push({
                    gridPos: torchPos,
                    type: 'torch',
                    essence: 'fire',
                    mesh: torchBase,
                    flame: flame,
                    name: 'Torch'
                });
                
                setGridOccupied(torchPos.x, torchPos.z, true);
            }
        }
        
        function createCharacter() {
            const characterGeometry = new THREE.BoxGeometry(0.8, 1.6, 0.4);
            const characterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF69B4
            });
            character = new THREE.Mesh(characterGeometry, characterMaterial);
            
            characterGridPos = { x: 0, z: 0 };
            const worldPos = gridToWorld(characterGridPos.x, characterGridPos.z);
            character.position.set(worldPos.x, 0.8, worldPos.z);
            characterPosition.x = worldPos.x;
            characterPosition.z = worldPos.z;
            
            character.castShadow = true;
            scene.add(character);
            
            const faceGeometry = new THREE.SphereGeometry(0.15);
            const faceMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDDAA });
            const face = new THREE.Mesh(faceGeometry, faceMaterial);
            face.position.set(0, 0.3, 0.25);
            character.add(face);
            
            const eyeGeometry = new THREE.SphereGeometry(0.03);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.05, 0.05, 0.1);
            face.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.05, 0.05, 0.1);
            face.add(rightEye);
        }
        
        // Game input handlers
        function handleGameKeyDown(event) {
            if (!keys[event.code] && !keyPressed[event.code]) {
                keys[event.code] = true;
                keyPressed[event.code] = true;
                
                // Handle movement
                if (['KeyW', 'KeyS', 'KeyA', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                    handleGridMovement(event.code);
                }
                // Handle essence system
                else if (event.code === 'KeyE') {
                    handleEssenceAction();
                }
                // Handle world interaction
                else if (event.code === 'KeyF') {
                    handleWorldInteraction();
                }
            }
        }
        
        function handleGameKeyUp(event) {
            keys[event.code] = false;
            keyPressed[event.code] = false;
        }
        
        function handleGridMovement(keyCode) {
            if (isMoving) return;
            
            let newGridX = characterGridPos.x;
            let newGridZ = characterGridPos.z;
            let direction = '';
            
            switch(keyCode) {
                case 'KeyW':
                case 'ArrowUp':
                    newGridZ -= 1;
                    direction = 'up';
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    newGridZ += 1;
                    direction = 'down';
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    newGridX -= 1;
                    direction = 'left';
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    newGridX += 1;
                    direction = 'right';
                    break;
                default:
                    return;
            }
            
            // Check if there's a box in the way that needs to be pushed
            if (boxGridPos.x === newGridX && boxGridPos.z === newGridZ) {
                let boxNewX = boxGridPos.x;
                let boxNewZ = boxGridPos.z;
                
                switch(direction) {
                    case 'up': boxNewZ -= 1; break;
                    case 'down': boxNewZ += 1; break;
                    case 'left': boxNewX -= 1; break;
                    case 'right': boxNewX += 1; break;
                }
                
                if (isValidGridPosition(boxNewX, boxNewZ)) {
                    pushBox(boxNewX, boxNewZ);
                    startMovementAnimation(newGridX, newGridZ, direction);
                }
                return;
            }
            
            if (isValidGridPosition(newGridX, newGridZ)) {
                startMovementAnimation(newGridX, newGridZ, direction);
            }
        }
        
        let movementData = {
            startPos: { x: 0, z: 0 },
            endPos: { x: 0, z: 0 },
            progress: 0,
            direction: ''
        };
        
        function startMovementAnimation(newGridX, newGridZ, direction) {
            isMoving = true;
            
            movementData.startPos.x = characterPosition.x;
            movementData.startPos.z = characterPosition.z;
            movementData.endPos = gridToWorld(newGridX, newGridZ);
            movementData.progress = 0;
            movementData.direction = direction;
            
            rotateCharacterForDirection(direction);
            
            characterGridPos.x = newGridX;
            characterGridPos.z = newGridZ;
            
            updatePositionDisplay();
            updateMinimap();
        }
        
        function rotateCharacterForDirection(direction) {
            switch(direction) {
                case 'up':
                    character.rotation.y = 0;
                    break;
                case 'down':
                    character.rotation.y = Math.PI;
                    break;
                case 'left':
                    character.rotation.y = Math.PI / 2;
                    break;
                case 'right':
                    character.rotation.y = -Math.PI / 2;
                    break;
            }
        }
        
        function updateMovementAnimation() {
            if (!isMoving) return;
            
            movementData.progress += movementSpeed;
            
            if (movementData.progress >= 1) {
                movementData.progress = 1;
                isMoving = false;
            }
            
            const t = easeInOutCubic(movementData.progress);
            characterPosition.x = lerp(movementData.startPos.x, movementData.endPos.x, t);
            characterPosition.z = lerp(movementData.startPos.z, movementData.endPos.z, t);
            
            character.position.x = characterPosition.x;
            character.position.z = characterPosition.z;
            
            camera.position.x = characterPosition.x;
            camera.position.z = characterPosition.z + 8;
            camera.lookAt(characterPosition.x, 0, characterPosition.z);
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function pushBox(newX, newZ) {
            setGridOccupied(boxGridPos.x, boxGridPos.z, false);
            
            boxGridPos.x = newX;
            boxGridPos.z = newZ;
            
            setGridOccupied(newX, newZ, true);
            
            const newWorldPos = gridToWorld(newX, newZ);
            pushableBox.position.x = newWorldPos.x;
            pushableBox.position.z = newWorldPos.z;
            
            updateMinimap();
        }
        
        function handleEssenceAction() {
            if (playerEssence === null) {
                getEssenceFromObject();
            } else {
                transferEssenceToBox();
            }
        }
        
        function handleWorldInteraction() {
            console.log("World interaction - coming soon!");
        }
        
        function getEssenceFromObject() {
            const facingPos = getFacingPosition();
            
            const obj = interactionObjects.find(o => 
                o.gridPos.x === facingPos.x && o.gridPos.z === facingPos.z
            );
            
            if (obj && obj.essence) {
                playerEssence = obj.essence;
                updateEssenceDisplay();
                
                if (obj.flame) {
                    obj.flame.material.opacity = 0.4;
                }
                
                console.log(`Collected ${obj.essence} essence from ${obj.name}!`);
            }
        }
        
        function transferEssenceToBox() {
            if (isNextToBox()) {
                boxEssence = playerEssence;
                playerEssence = null;
                updateEssenceDisplay();
                updateBoxAppearance();
                
                console.log(`Transferred ${boxEssence} essence to box!`);
            }
        }
        
        function getFacingPosition() {
            const adjacentPositions = [
                { x: characterGridPos.x, z: characterGridPos.z - 1 },
                { x: characterGridPos.x, z: characterGridPos.z + 1 },
                { x: characterGridPos.x - 1, z: characterGridPos.z },
                { x: characterGridPos.x + 1, z: characterGridPos.z }
            ];
            
            for (let pos of adjacentPositions) {
                const obj = interactionObjects.find(o => 
                    o.gridPos.x === pos.x && o.gridPos.z === pos.z
                );
                if (obj) return pos;
            }
            
            return { x: characterGridPos.x, z: characterGridPos.z - 1 };
        }
        
        function isNextToBox() {
            const dx = Math.abs(characterGridPos.x - boxGridPos.x);
            const dz = Math.abs(characterGridPos.z - boxGridPos.z);
            return (dx === 1 && dz === 0) || (dx === 0 && dz === 1);
        }
        
        function updateEssenceDisplay() {
            const essenceDisplay = document.getElementById('essence-display');
            if (essenceDisplay) {
                if (playerEssence) {
                    const essenceEmoji = getEssenceEmoji(playerEssence);
                    essenceDisplay.textContent = `🔮 Essence: ${essenceEmoji} ${capitalizeFirst(playerEssence)}`;
                } else {
                    essenceDisplay.textContent = '🔮 Essence: None';
                }
            }
        }
        
        function updateBoxAppearance() {
            if (boxEssence === 'fire') {
                pushableBox.material.color.setHex(0xff4500);
                pushableBox.material.emissive.setHex(0x330000);
            } else {
                pushableBox.material.color.setHex(0x8B4513);
                pushableBox.material.emissive.setHex(0x000000);
            }
        }
        
        function getEssenceEmoji(essence) {
            const emojis = {
                'fire': '🔥',
                'wind': '💨',
                'cannon': '💣',
                'steel': '🛡️'
            };
            return emojis[essence] || '🔮';
        }
        
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        function updatePositionDisplay() {
            const positionDisplay = document.querySelector('#gameContainer .game-ui div:nth-child(3)');
            if (positionDisplay) {
                positionDisplay.textContent = `📍 Grid: (${characterGridPos.x}, ${characterGridPos.z})`;
            }
        }
        
        function initMinimap() {
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');
            updateMinimap();
        }
        
        function updateMinimap() {
            const canvas = minimapCanvas;
            const ctx = minimapCtx;
            const size = 140;
            const viewRadius = 8;
            
            ctx.clearRect(0, 0, size, size);
            
            ctx.fillStyle = 'rgba(26, 47, 10, 0.5)';
            ctx.fillRect(0, 0, size, size);
            
            const gridCount = (viewRadius * 2 + 1);
            const tileSize = Math.floor(size / gridCount);
            const totalGridSize = tileSize * gridCount;
            const offset = (size - totalGridSize) / 2;
            
            const playerX = characterGridPos.x;
            const playerZ = characterGridPos.z;
            
            for (let x = playerX - viewRadius; x <= playerX + viewRadius; x++) {
                for (let z = playerZ - viewRadius; z <= playerZ + viewRadius; z++) {
                    const screenX = offset + (x - (playerX - viewRadius)) * tileSize;
                    const screenZ = offset + (z - (playerZ - viewRadius)) * tileSize;
                    
                    const key = `${x},${z}`;
                    const isOccupied = gridMap[key];
                    const isOutOfBounds = x < -HALF_GRID || x > HALF_GRID || z < -HALF_GRID || z > HALF_GRID;
                    
                    let color;
                    if (isOutOfBounds) {
                        color = 'rgba(26, 47, 10, 0.8)';
                    } else if (isOccupied) {
                        if (isWaterTile(x, z)) {
                            color = '#1E90FF';
                        } else if (isTreeTile(x, z)) {
                            color = '#2d5016';
                        } else {
                            color = '#555555';
                        }
                    } else {
                        const isEvenTile = (x + z) % 2 === 0;
                        color = isEvenTile ? '#4a7c1e' : '#486b1d';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(screenX, screenZ, tileSize, tileSize);
                    
                    if (!isOutOfBounds) {
                        ctx.strokeStyle = 'rgba(61, 105, 25, 0.4)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(screenX, screenZ, tileSize, tileSize);
                    }
                }
            }
            
            // Draw box if in view
            if (Math.abs(boxGridPos.x - playerX) <= viewRadius && Math.abs(boxGridPos.z - playerZ) <= viewRadius) {
                const boxScreenX = offset + (boxGridPos.x - (playerX - viewRadius)) * tileSize;
                const boxScreenZ = offset + (boxGridPos.z - (playerZ - viewRadius)) * tileSize;
                
                let boxColor = '#8B4513';
                if (boxEssence === 'fire') {
                    boxColor = '#ff4500';
                } else if (boxEssence === 'wind') {
                    boxColor = '#87CEEB';
                } else if (boxEssence === 'cannon') {
                    boxColor = '#2F4F4F';
                } else if (boxEssence === 'steel') {
                    boxColor = '#C0C0C0';
                }
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(boxScreenX - 1, boxScreenZ - 1, tileSize + 2, tileSize + 2);
                
                ctx.fillStyle = boxColor;
                ctx.fillRect(boxScreenX, boxScreenZ, tileSize, tileSize);
            }
            
            // Draw player (perfectly centered)
            const playerScreenX = offset + viewRadius * tileSize;
            const playerScreenZ = offset + viewRadius * tileSize;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(playerScreenX - 1, playerScreenZ - 1, tileSize + 2, tileSize + 2);
            
            ctx.fillStyle = '#FF69B4';
            ctx.fillRect(playerScreenX, playerScreenZ, tileSize, tileSize);
            
            // Draw essence objects
            interactionObjects.forEach(obj => {
                if (Math.abs(obj.gridPos.x - playerX) <= viewRadius && Math.abs(obj.gridPos.z - playerZ) <= viewRadius) {
                    const objScreenX = offset + (obj.gridPos.x - (playerX - viewRadius)) * tileSize;
                    const objScreenZ = offset + (obj.gridPos.z - (playerZ - viewRadius)) * tileSize;
                    
                    let objColor = '#ff4500';
                    if (obj.type === 'torch') {
                        objColor = playerEssence === obj.essence ? '#cc3300' : '#ff4500';
                    }
                    
                    ctx.fillStyle = objColor;
                    ctx.fillRect(objScreenX + 1, objScreenZ + 1, tileSize - 2, tileSize - 2);
                }
            });
        }
        
        function isWaterTile(x, z) {
            const pondTiles = [
                { x: -8, z: -8 }, { x: -7, z: -8 }, { x: -6, z: -8 },
                { x: -8, z: -7 }, { x: -7, z: -7 }, { x: -6, z: -7 },
                { x: -8, z: -6 }, { x: -7, z: -6 }, { x: -6, z: -6 }
            ];
            return pondTiles.some(tile => tile.x === x && tile.z === z);
        }
        
        function isTreeTile(x, z) {
            const treeGridPositions = [
                { x: -4, z: -4 }, { x: 4, z: -4 }, { x: -4, z: 4 }, { x: 4, z: 4 },
                { x: -6, z: 0 }, { x: 6, z: 0 }, { x: 0, z: -6 }, { x: 0, z: 6 },
                { x: -10, z: -8 }, { x: 8, z: -12 }, { x: -12, z: 10 }, { x: 12, z: 8 },
                { x: -15, z: -15 }, { x: 15, z: -15 }, { x: -15, z: 15 }, { x: 15, z: 15 },
                { x: -8, z: -20 }, { x: 8, z: 20 }, { x: -20, z: 8 }, { x: 20, z: -8 },
                { x: -18, z: 0 }, { x: 18, z: 0 }, { x: 0, z: -18 }, { x: 0, z: 18 },
                { x: -22, z: -10 }, { x: 22, z: 10 }, { x: -10, z: 22 }, { x: 10, z: -22 },
                { x: -24, z: -5 }, { x: 24, z: 5 }, { x: -5, z: -24 }, { x: 5, z: 24 },
                { x: -25, z: 0 }, { x: 25, z: 0 }, { x: 0, z: -25 }, { x: 0, z: 25 },
                { x: -23, z: 17 }, { x: 23, z: -17 }, { x: -17, z: 23 }, { x: 17, z: -23 }
            ];
            return treeGridPositions.some(tile => tile.x === x && tile.z === z);
        }
        
        function updateCharacterAnimations() {
            if (!isMoving) {
                character.position.y = 0.8 + Math.sin(Date.now() * 0.003) * 0.02;
            } else {
                character.position.y = 0.8 + Math.sin(Date.now() * 0.02) * 0.1;
            }
        }
        
                 // ==========================================
         // PERFORMANCE MONITORING
         // ==========================================
         
         // Frame rate monitoring (from the guide)
         let perfLast = performance.now();
         let perfAcc = 0;
         let perfFrames = 0;
         let fpsDisplay = null;
         
         // Create FPS display element
         function createFPSDisplay() {
             if (!fpsDisplay) {
                 fpsDisplay = document.createElement('div');
                 fpsDisplay.style.cssText = `
                     position: fixed;
                     top: 10px;
                     left: 10px;
                     background: rgba(0,0,0,0.8);
                     color: #00ff00;
                     padding: 5px 10px;
                     font-family: monospace;
                     font-size: 14px;
                     border-radius: 4px;
                     z-index: 10000;
                     pointer-events: none;
                 `;
                 document.body.appendChild(fpsDisplay);
             }
         }
         
         // Update FPS counter every second
         setInterval(() => {
             if (gameState === 'game' && perfFrames > 0) {
                 const fps = Math.round(perfFrames * 1000 / perfAcc);
                 console.log(`🎯 Game FPS: ${fps}`);
                 
                 if (fpsDisplay) {
                     fpsDisplay.textContent = `FPS: ${fps}`;
                     fpsDisplay.style.color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffaa00' : '#ff0000';
                 }
             }
             perfFrames = 0;
             perfAcc = 0;
         }, 1000);

         function animate() {
             if (gameState !== 'game') return;
             
             // Performance tracking
             const now = performance.now();
             const dt = now - perfLast;
             perfLast = now;
             perfAcc += dt;
             perfFrames++;
             
             // Show FPS display in development mode or if performance monitoring is needed
             const isDevMode = window.location.protocol === 'file:' || window.location.hostname === 'localhost';
             if ((isDevMode || perfFrames % 60 === 0) && !fpsDisplay) {
                 createFPSDisplay();
             }
             
             requestAnimationFrame(animate);
            
            updateMovementAnimation();
            updateCharacterAnimations();
            
            // Animate water
            const water = world.children.find(child => 
                child.material && child.material.color && 
                child.material.color.getHex() === 0x1E90FF
            );
            if (water) {
                water.material.opacity = 0.7 + Math.sin(Date.now() * 0.003) * 0.1;
            }
            
            // Animate trees
            world.children.forEach(child => {
                if (child.material && child.material.color && 
                    child.material.color.getHex() === 0x228B22) {
                    child.rotation.z = Math.sin(Date.now() * 0.002 + child.position.x) * 0.05;
                }
            });
            
            // Animate torch flames
            interactionObjects.forEach(obj => {
                if (obj.type === 'torch' && obj.flame) {
                    obj.flame.scale.y = 1.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    obj.flame.rotation.z = Math.sin(Date.now() * 0.008) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
                 // Optimized canvas resize with device pixel ratio handling
         function resizeCanvas() {
             if (!gameInitialized || !renderer || !camera) return;
             
             const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap pixel ratio for performance
             const width = Math.floor(window.innerWidth * dpr);
             const height = Math.floor(window.innerHeight * dpr);
             
             // Only resize if dimensions actually changed
             const canvas = renderer.domElement;
             if (canvas.width !== width || canvas.height !== height) {
                 // Update camera aspect ratio
                 const aspect = window.innerWidth / window.innerHeight;
                 const frustumSize = 20;
                 camera.left = frustumSize * aspect / -2;
                 camera.right = frustumSize * aspect / 2;
                 camera.top = frustumSize / 2;
                 camera.bottom = frustumSize / -2;
                 camera.updateProjectionMatrix();
                 
                 // Update renderer size
                 renderer.setSize(window.innerWidth, window.innerHeight);
                 renderer.setPixelRatio(dpr);
                 
                 console.log(`🖼️  Canvas resized: ${window.innerWidth}x${window.innerHeight} (${dpr}x DPR)`);
             }
         }

         // Handle window resize with debouncing
         let resizeTimeout;
         window.addEventListener('resize', () => {
             clearTimeout(resizeTimeout);
             resizeTimeout = setTimeout(resizeCanvas, 16); // ~60fps debouncing
         });
        
        // ==========================================
        // NOTIFICATION SYSTEM
        // ==========================================
        
        function showNotification(message, duration = 3000) {
            // Remove existing notification if present
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            // Add to document
            document.body.appendChild(notification);
            
            // Animate in
            requestAnimationFrame(() => {
                notification.classList.add('show');
            });
            
            // Auto-remove after duration
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('fade-out');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, duration);
        }
        
        // ==========================================
        // ELECTRON API INTEGRATION
        // ==========================================
        
        // Listen for menu bar toggle events from Electron main process
        if (window.electronAPI) {
            window.electronAPI.onMenuBarToggled((event, data) => {
                console.log('🔧 Menu bar toggled:', data.message);
                showNotification(`🔧 ${data.message}`);
            });
        }
        
        // Ensure smooth loading
        document.body.style.opacity = '1';
    </script>
</body>
</html>
